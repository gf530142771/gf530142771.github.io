<!-- TOC -->

- [枚举](#枚举)
    - [数字枚举](#数字枚举)
        - [反向映射](#反向映射)
    - [字符串枚举](#字符串枚举)
    - [异类枚举](#异类枚举)
    - [计算的常量成员](#计算的常量成员)
    - [联合枚举和枚举成员类型](#联合枚举和枚举成员类型)
    - [const 枚举](#const-枚举)

<!-- /TOC -->
## 枚举

### 数字枚举
```ts
enum Director {
    Left = 1,
    Righr,
    Up,
    Down
}
```

转换为js
```js
var Director;
(function (Director) {
    Director[Director["Left"] = 1] = "Left";
    Director[Director["Righr"] = 2] = "Righr";
    Director[Director["Up"] = 3] = "Up";
    Director[Director["Down"] = 4] = "Down";
})(Director || (Director = {}))}
```
这样就产生了反向映射

#### 反向映射
只有`数字枚举`会生成反向映射

```ts
console.log(Director.Left);//1
console.log(Director[1]);//Left
```

### 字符串枚举
```ts
enum DirString{
    Up = 'Up',
    Down = 'Down',
    Left = 'Left',
    Right ='Up',
}
```

转为js
```js
var DirString;
(function (DirString) {
    DirString["Up"] = "Up";
    DirString["Down"] = "Down";
    DirString["Left"] = "Left";
    DirString["Right"] = "Up";
})(DirString || (DirString = {}));
```
`不会产生反向映射`

### 异类枚举 
```ts
enum BooleanLikeHeterogeneousEnum {
    No = 0,
    Yes = "YES",
}
```

没有特殊的用法最好不要这么写

### 计算的常量成员
常量枚举表达式
```ts
enum FileAccess {
    // constant members
    None,
    Read    = 1 << 1,
    Write   = 1 << 2,
    ReadWrite  = Read | Write,
    // computed member
    G = "123".length
}
```
### 联合枚举和枚举成员类型
字面量枚举成员
* 字符串字面量("a")
* 数字字面量(0,100)
* 负数(-1,-2)

这样的枚举成员就成了类型

```ts
enum ShapeKind {
    Circle,
    Square,
}

interface Circle {
    kind: ShapeKind.Circle;
    radius: number;
}

interface Square {
    kind: ShapeKind.Square;
    sideLength: number;
}
```

同样枚举就变成了每个`枚举成员`的联合
`ShapeKind` 的类型就是 `ShapeKind.Circle | ShapeKind.Square`

### const 枚举
常量枚举只能使用常量枚举表达式，并且不同于常规的枚举，它们在编译阶段会被删除 不会出现在编译完成的js文件中
```js
const enum Directions {
    Up,
    Down,
    Left,
    Right
}

let directions = [Directions.Up, Directions.Down, Directions.Left, Directions.Right]
```
编译后的js内容
```ts
var directions = [0 /* Up */, 1 /* Down */, 2 /* Left */, 3 /* Right */];
```
