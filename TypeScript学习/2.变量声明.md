<!-- TOC -->

- [变量声明](#变量声明)
    - [var 和 let](#var-和-let)
        - [var](#var)
        - [let](#let)
        - [作用域的问题](#作用域的问题)
    - [解构](#解构)
        - [数组解构](#数组解构)
        - [对象解构](#对象解构)
    - [...展开](#展开)
        - [1.将一个数组展开为另一个数组](#1将一个数组展开为另一个数组)
        - [2.展开对象](#2展开对象)

<!-- /TOC -->
## 变量声明

### var 和 let
ES6中有过详细介绍，基本用法一致
#### var
经常出现的一些问题
* var存在变量提升 **与js一样不在多次赘述**
* var不论声明多少次 你只会得到一个
```ts
function test(): number {
    var sum = 0;
    for (var i = 0; i < 10; i++) {
        console.log("outSide i ", i);
        //重复声明不会报错,从而导致循环并不是按照你的预期进行,
        for (var i = 0; i < 11; i++) {
            console.log("inside i ", i);
        }
    }
    return sum;
}

test();
/*
outSide i  0
inside i  0
inside i  1
inside i  2
inside i  3
inside i  4
inside i  5
inside i  6
inside i  7
inside i  8
inside i  9
inside i  10
*/
```
#### let
* let 声明的变量在使用前 会发生错误 ，这就是TDZ(Temporal Dead Zone)暂时性死区
```ts
console.log(a);//声明之前已使用的块范围变量“a”。
let a: number = 10;
```
**特例**  
有一种情况不会 当 let 声明的变量在一个函数中被调用 只要在声明前没有调用过该函数 不会报错产生死区。
```ts
function test2() {
    return a;
}
let a: number = 10;
console.log(test2());
```

#### 作用域的问题
var 只受**全局作用域**和**函数作用域**的影响。  
let 同时还要受到**块级作用域**约束
```ts
let data1 = 10;
var data2 = 20;
if (data1 === 10 && data2 === 20) {
    let data1 = 100;
    var data2 = 100;
}
console.log(data1, data2);//10,100
```

### 解构
[参考地址](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment)
#### 数组解构
```ts
// 数组解构
let [num1, num2] = [1, 2, 3, 4];//1,2

let [, number2, , number4] = [5, 6, 7, 8];//6,8

// ...rest
let [number1, ...rest] = [1, 2, 3, 4, 5];//1,[2,3,4,5]
```

#### 对象解构
* 普通模式
```ts
let objTest = { oa: 10, ob: 20, oc: "datastring", od: "odstr" }
let { oa, ob, oc } = objTest;
console.log(oa, ob, oc);//10,20 datastring
let { od, ...restO } = objTest;
console.log(od, restO);//datastring { oa: 10, ob: 20 }
```
* 属性重命名  

```ts
let { oa: obj1, ob: obj2 }: { oa: number, ob: number } = objTest;
console.log(obj1, obj2);//10 20
```

* 默认值
```ts
let { oe = 1000 }: { oe?: number, [indexs: string]: any } = { oa: "stringa" };
console.log(oe);//1000

function keepWholeObject({ oe = 1000 }: { [indexs: string]: any }) {
    console.log(oe);
}

keepWholeObject({ a: 100, oe: 2000 });//2000
```

* 类型推断
```ts
function f({ a = 10, b = "a" } = {}) {

}//类型推断 推断为{a?:number,b?:string}
f({ b: "100" });

function f2({ a, b = 0 } = { a: "" }): void {
    // ...
}//推断类型 { a: string; b?: number; }
f2({ a: "ok" })
```
### ...展开
#### 1.将一个数组展开为另一个数组
```ts
let first = [1, 2];
let second = [3, 4];
let aaa;
let third = [0, ...first, ...second, 5, 6];
console.log('third:', third);
```
#### 2.展开对象
* 仅仅包含对象的自身的可枚举类型
```ts
class testC {
    name = 14;
    funcTest() {

    }
}
let testc = new testC();
console.log({ ...testc });//{ name: 14 }
```

* 同名属性会被覆盖
```ts
let defaults = {
    a: 10,
    b: 100,
    name: 'bob',
    func: function () {

    }
};
let testObj = { a: 100, ...defaults };
console.log('testObj:', testObj);//testObj: { a: 10, b: 100, name: 'bob', func: [Function: func] }
```









