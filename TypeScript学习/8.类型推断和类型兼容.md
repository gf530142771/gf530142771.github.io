## 类型推断
ts对未设置类型变量会进行类型推断
## 类型兼容性

基本原则

`X`要兼容`Y`, `Y`至少要有`X`的相同属性

### 函数兼容
* 函数返回值兼容性
函数返回值的兼容 使用类型兼容基本原则

* 函数参数的兼容性  
函数X的每个参数都能在函数Y中找到位置并且类型相同的参数 名字无所谓


### 枚举兼容
* 数字类型 和 枚举类型 兼容

```ts
enum Director {
    Left = 1,
    Righr,
    Up,
    Down
}
let state :Director = 10;
```
* 不同枚举间不兼容

### 类的兼容性
* 属性没有修饰符修饰时 和对象差不多
```ts
class Animal {
    feet: number;
    constructor(name: string, numFeet: number) { }
}

class Size {
    feet: number;
    constructor(numFeet: number) { }
}

let a: Animal;
let s: Size;

a = s;  // OK
s = a;  // OK
```
* 私有成员和受保护的成员
类的私有变量和受保护变量 必须时同一声明 详情参看 private 和 protected
也就是说父类 兼容 子类

### 泛型的兼容
* 没有指定泛型类型的泛型参数时，统一按照any处理,指定参数时便不会兼容
```ts
interface Empty<T> {
}
let x: Empty<number>;
let y: Empty<string>;

x = y;  // OK, because y matches structure of x

interface NotEmpty<T> {
    data: T;
}
let x: NotEmpty<number>;
let y: NotEmpty<string>;

x = y;  // Error, because x and y are not compatible
```




