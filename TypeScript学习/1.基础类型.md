<!-- TOC -->

- [基础类型](#基础类型)
    - [number](#number)
    - [布尔型 boolean](#布尔型-boolean)
    - [字符串](#字符串)
    - [数组](#数组)
    - [元组 Tuple](#元组-tuple)
    - [枚举](#枚举)
    - [any](#any)
    - [void](#void)
    - [null undefined](#null-undefined)
    - [Never](#never)
    - [Object](#object)
    - [类型断言](#类型断言)

<!-- /TOC -->
## 基础类型

### number
所有数字都是浮点数 支持二进制 0b 八进制 0o 十进制100 十六进制 0x

### 布尔型 boolean
布尔值

### 字符串
使用''或者 ""表示字符串  也可以使用模板字符串 `` 使用 ${}嵌入表达式
```ts
let bob = {
    name: 'bob',
    age: 10
}
let bobInfo = `pperson name is ${bob.name},
age is ${bob.age + 1};
`
console.log(bobInfo);
/*
pperson name is bob,
age is 11;
*/
```

### 数组
两种表示方法  
* 直接在元素类型的后面加上 []
```ts
let array1: number[] = [1, 2, 3, 4];
console.log(array1);//[ 1, 2, 3, 4 ]
```
* 数组泛型
```ts
let array2: Array<string> = ['hello', 'world', '!'];
console.log(array2);//[ 'hello', 'world', '!' ]
```

### 元组 Tuple
表示一个已知元素数量和类型的数组 各类型不必相同 
```ts
let tuple: [string, number];
tuple = ['key1', 1];
console.log(tuple[0]);//key1
```
**元组越界后会使用联合类型**
```ts
tuple.push(100);//可以 100 是 number 类型
console.log(tuple.length);
// tuple.push(false); //类型“boolean”的参数不能赋给类型“string | number”的参数
```

### 枚举  

```ts
enum Color { Red, Black };
```
**后面详细讲解**

### any
与 Object的区别 Object类型的变量允许赋任意值 但是只能调用Object上的的方法  
any 没有这个限制
```ts
let any1: any = 10;
console.log(any1.toFixed());
let object1: Object = 10;
// console.log(object1.toFixed());//类型“Object”上不存在属性“toFixed”
```

### void
* 只能被赋予 null undefined
* 函数无返回值是可以使用 void

### null undefined
* TypeScript里，undefined和null两者各自有自己的类型分别叫做undefined和null  
* 当你指定了**strictNullChecks**标记，null和undefined只能赋值给void和它们各自 默认这个标记是关闭的  

### Never
永远不存在的类型 任何值都不能赋值给never 总是会抛出异常或者根本不会有返回值的函数 可以返回Never
```ts
// 返回never的函数必须存在无法达到的终点
function error(message: string): never {
    throw new Error(message);
}

// 推断的返回值类型为never
function fail() {
    return error("Something failed");
}

// 返回never的函数必须存在无法达到的终点
function infiniteLoop(): never {
    while (true) {
    }
}
```

### Object 
非原始类型

### 类型断言
* 类型断言 as 或者 <> 使用jsx时 只能使用as语句
* 使用类型断言可以逃避编译器的数据检查和解构
* 没有运行时的影响 只是会影响编译阶段