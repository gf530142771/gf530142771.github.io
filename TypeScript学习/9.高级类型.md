<!-- TOC -->

- [高级类型](#高级类型)
    - [交叉类型](#交叉类型)
    - [联合类型](#联合类型)
    - [类型保护与区分类型](#类型保护与区分类型)
    - [类型别名 type](#类型别名-type)
    - [字符串字面量类型](#字符串字面量类型)
    - [可辨识联合](#可辨识联合)
    - [索引类型](#索引类型)
    - [映射类型](#映射类型)

<!-- /TOC -->
## 高级类型

### 交叉类型
多种类型可以叠加成一种类型
关键字 & 
TS源码
```ts
interface ObjectConstructor {
  assign<T, U>(target: T, source: U): T & U;
}
```

```ts
interface A {
  name: string,
  age: number,
  sayName: (name: string) => void
}
interface B {
  name: string,
  gender: string,
  sayGender: (gender: string) => void
}

let a: A & B

// 都是合法的
a.age
a.sayName
```

### 联合类型
联合类型表示一个值可以是几种类型之一。 我们用竖线（ |）分隔每个类型，所以 number | string | boolean表示一个值可以是 number， string，或 boolean。

### 类型保护与区分类型
* typeof
这些**typeof类型保护**只有两种形式能被识别： typeof v === "typename"和 typeof v !== "typename"。  
"typename"必须是 "number"， "string"， "boolean"或 "symbol"。
```ts
function padLeft(value: string, padding: string | number) {
    if (typeof padding === "number") {
        return Array(padding + 1).join(" ") + value;
    }
    if (typeof padding === "string") {
        return padding + value;
    }
    throw new Error(`Expected string or number, got '${padding}'.`);
}
```
* instanceof
instanceof类型保护是通过构造函数来细化类型的一种方式
**instanceof的右侧要求是一个构造函数**
```ts
interface Padder {
    getPaddingString(): string
}

class SpaceRepeatingPadder implements Padder {
    constructor(private numSpaces: number) { }
    getPaddingString() {
        return Array(this.numSpaces + 1).join(" ");
    }
}

class StringPadder implements Padder {
    constructor(private value: string) { }
    getPaddingString() {
        return this.value;
    }
}

function getRandomPadder() {
    return Math.random() < 0.5 ?
        new SpaceRepeatingPadder(4) :
        new StringPadder("  ");
}

// 类型为SpaceRepeatingPadder | StringPadder
let padder: Padder = getRandomPadder();

if (padder instanceof SpaceRepeatingPadder) {
    padder; // 类型细化为'SpaceRepeatingPadder'
}
if (padder instanceof StringPadder) {
    padder; // 类型细化为'StringPadder'
}
```
* is
```ts
interface Bird {
    fly();
    layEggs();
}

interface Fish {
    swim();
    layEggs();
}

function getSmallPet(): Fish | Bird {
    // ...
}
function isFish(pet: Fish | Bird): pet is Fish {
    return (<Fish>pet).swim !== undefined;
}

// 'swim' 和 'fly' 调用都没有问题了
let pet = getSmallPet();
if (isFish(pet)) {
    pet.swim();
}
else {
    pet.fly();
}
```

### 类型别名 type
字面意思 给类型起一个别的名字
```ts
type Name = string;
type NameResolver = () => string;
type NameOrResolver = Name | NameResolver;
function getName(n: NameOrResolver): Name {
    if (typeof n === 'string') {
        return n;
    }
    else {
        return n();
    }
}
```

**类型别名**也可以是泛型     

```ts
type Container<T> = { value: T };
```

和接口的区别
* 类型别名不会创建一个新的名字 接口会创建一个新的名字
* 类型别名不能 extends 和 implements

### 字符串字面量类型
字符串字面量类型允许你指定字符串必须的固定值。 在实际应用中，字符串字面量类型可以与联合类型，类型保护和类型别名很好的配合
```ts
type Easing = "ease-in" | "ease-out" | "ease-in-out";
class UIElement {
    animate(dx: number, dy: number, easing: Easing) {
        if (easing === "ease-in") {
            // ...
        }
        else if (easing === "ease-out") {
        }
        else if (easing === "ease-in-out") {
        }
        else {
            // error! should not pass null or undefined.
        }
    }
}

let button = new UIElement();
button.animate(0, 0, "ease-in");
button.animate(0, 0, "uneasy"); // error: "uneasy" is not allowed here
```

你只能从三种允许的字符中选择其一来做为参数传递，传入其它值则会产生错误。

**字符串字面量类型还可以用于区分函数重载**
```ts
function createElement(tagName: "img"): HTMLImageElement;
function createElement(tagName: "input"): HTMLInputElement;
// ... more overloads ...
function createElement(tagName: string): Element {
    // ... code goes here ...
}
```


### 可辨识联合

```ts
interface Square {
    kind: "square";
    size: number;
}
interface Rectangle {
    kind: "rectangle";
    width: number;
    height: number;
}
interface Circle {
    kind: "circle";
    radius: number;
}
//首先我们声明了将要联合的接口。 
// 每个接口都有 kind属性但有不同的字符串字面量类型。 
// kind属性称做 可辨识的特征或 标签。
type Shape = Square | Rectangle | Circle;
function area(s: Shape) {
    switch (s.kind) {
        case "square": return s.size * s.size;
        case "rectangle": return s.height * s.width;
        case "circle": return Math.PI * s.radius ** 2;
    }
}
```

* 完整性检查
当没有涵盖所有可辨识联合的变化时，我们想让编译器可以通知我们。 比如，如果我们添加了 Triangle到 Shape，我们同时还需要更新 area:

使用`never`完成提示
```ts
function assertNever(x: never): never {
    throw new Error("Unexpected object: " + x);
}
function area(s: Shape) {
    switch (s.kind) {
        case "square": return s.size * s.size;
        case "rectangle": return s.height * s.width;
        case "circle": return Math.PI * s.radius ** 2;
        default: return assertNever(s); // error here if there are missing cases
    }
}
```

### 索引类型

```ts
function pluck<T, K extends keyof T>(o: T, names: K[]): T[K][] {
  return names.map(n => o[n]);
}

interface Person {
    name: string;
    age: number;
}
let person: Person = {
    name: 'Jarid',
    age: 35
};
let strings: string[] = pluck(person, ['name']); // ok, string[]
```
**索引类型和字符串索引签名**
```ts
interface Map<T> {
    [key: string]: T;
}
let keys: keyof Map<number>; // string
let value: Map<number>['foo']; // number
```

### 映射类型

* 同态映射类型
只操作类型的属性映射为另一个类型 不会新增属性
    * Readonly
    * Partial
    * Pick
    等

* 非同态映射类型
会引入新属性
    * 


