{"./":{"url":"./","title":"Introduction","keywords":"","body":" MarkdownNotes 介绍 个人笔记记录 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"AndroidStudio常见问题解决/":{"url":"AndroidStudio常见问题解决/","title":"AndroidStudio常见问题解决","keywords":"","body":" AndroidStudio常见问题解决 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"CocosCreatorMVC框架结构设计/1.设计总纲.html":{"url":"CocosCreatorMVC框架结构设计/1.设计总纲.html","title":"1.设计总纲","keywords":"","body":" 设计思路 1.MVC简单介绍 基本设计设计思路 设计思路 1.MVC简单介绍 Model数据模块 数据更新 View界面显示 主要负责显示数据和接收用户操作 Controller控制模块 主要功能是处理用户的请求 处理业务逻辑 所有的通信都是单向的 基本设计设计思路 淡化Controller的业务逻辑操作 每一个View和Model之间增加一个中介者Mediator来处理业务逻辑Mediator和View一一对应使用中介者模式 behavor 通过命令来控制Model使用命令模式 Model 的数据发生改变通过广播的形式来通知 所有的Model通过ModelManager管理 View 通过发送 Event 来通知 Mediator 进行业务逻辑处理 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"CocosCreatorMVC框架结构设计/":{"url":"CocosCreatorMVC框架结构设计/","title":"CocosCreatorMVC框架结构设计","keywords":"","body":" 说明 CocosCreator MVC框架设计 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"CocosCreator学习/1.资源的加载与释放.html":{"url":"CocosCreator学习/1.资源的加载与释放.html","title":"1.资源的加载与释放","keywords":"","body":" CocosCreator学习笔记(一) 资源的加载和释放 一.资源的缓存位置 二.引用计数法 三.静态引用和动态引用 静态引用 引擎如何处理静态引用 动态引用 1.动态加载resources中的资源 2.加载bundle中的资源 3.动态引用的资源管理 4.源码地址 资源删除流程图 CocosCreator学习笔记(一) 资源的加载和释放 一.资源的缓存位置 Creator的资源加载后会存储在cc.asssetManager.assets中 类型为cc.AssetManager.Cache 一个类似Map的结构 资源可以通过自动释放和手动释放的方式来进行释放 cc.assetManager管理资源的行为和信息，包括加载，释放等。 /*@example 释放单个资源 cc.assetManager.releaseAsset(texture); */ releaseAsset(asset: cc.Asset): void; /** 释放所有资源。详细信息请参考 */ releaseAll(): void; 二.引用计数法 cocos2d-x一种常用的内存管理计数，基本原理将资源的引用次数保存起来，每次释放计数减1，当计数为0时 释放掉资源 cocoscreator的资源函数addRef() 增加引用计数decRef(autoRelease) 减少引用计数注意: AssetManager只会自动统计静态引用 开发者动态引用的资源需要自己加以控制并释放 三.静态引用和动态引用 静态引用 直接在编辑器里使用的资源在编辑器里使用的资源 引擎会自动分析出以来资源的列表 这样的资源引用 被视为 静态引用 引擎如何处理静态引用 在静态加载某个资源时，引擎会记录该资源所有直接依赖资源的信息，并将所有直接依赖资源的引用计数加 1，然后将该资源的引用计数初始化为 0 在释放资源时，取得该资源之前记录的所有直接依赖资源信息，并将所有依赖资源的引用计数减1 只有资源的引用计数为0时才会被自动释 场景的自动释放 动态引用 1.动态加载resources中的资源 cc.resources.load(\"HelloWorld\", cc.SpriteFrame, (err, assets: cc.SpriteFrame) => { }); 2.加载bundle中的资源 cc.assetManager.loadBundle(\"bundle\", (err: Error, bundle: cc.AssetManager.Bundle) => { bundle.load(\"HelloWorld\", cc.SpriteFrame, (err, assets: cc.SpriteFrame) => { }); }); 注意resources其实也是官方内置的Asset Bundlecc.resources的类型其实就是 export var resources: AssetManager.Bundle; 官方内置的Bundle 内置 Asset Bundle 功能说明 配置 internal| 存放所有内置资源以及其依赖资源| 通过配置 资源管理器 中的 internal -> resources 文件夹，但目前不支持修改默认配置main |存放所有在 构建发布 面板的 参与构建场景 中勾选的场景以及其依赖资源 |通过配置 构建发布 面板的 主包压缩类型 和 配置主包为远程包 两项 resources|存放 resources 目录下的所有资源以及其依赖资源 |通过配置 资源管理器 中的 assets -> resources 文件夹 start-scene |如果在 构建发布 面板中勾选了 初始场景分包，则首场景将会被构建到 start-scene 中。具体内容可参考 初始场景的资源加载。|无法进行配置 所以读取resources中的资源使也可以这样 let bundle = cc.assetManager.getBundle('resources'); bundle.load(\"HelloWorld\", cc.SpriteFrame, (err, assets: cc.SpriteFrame) => { }); 3.动态引用的资源管理 通过decRef()的方法 使引用计数-1creator会根据计数自动进行释放资源。 使用assetManager 的相关接口来手动释放资源cc.assetManager.releaseAsset(texture); 注意： release系列接口 会直接释放资源 不会进行检查计数。 4.源码地址 /Resources/engine/cocos2d/core/asset-manager/releaseManager.js 资源删除流程图 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"CocosCreator学习/":{"url":"CocosCreator学习/","title":"CocosCreator学习","keywords":"","body":" 说明 cocoscreator 2.4版本学习笔记添加资源管理板块 2021-03-15 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"CocosCreator学习/优秀的第三方插件/":{"url":"CocosCreator学习/优秀的第三方插件/","title":"优秀的第三方插件","keywords":"","body":" MarkdownNotes 介绍 CocosCreator 第三方插件 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"CocosCreator学习/编辑器扩展/字段参考.html":{"url":"CocosCreator学习/编辑器扩展/字段参考.html","title":"字段参考","keywords":"","body":" 主菜单字段参考 面板字段参考 面板type类型 主菜单字段参考 字段名 类型 简介 message String IPC小子字段，点击菜单后，发送该字段到主进程中 command String 直接在主进程中运行全局函数 与message不能共存 params Array 消息参数，使发送的消息带有参数 accelerator String 快捷键注册字段,具体敌营规则 参考Accelerator icon String 为菜单定义icon visible Boolean 控制菜单是否隐藏 enabled Boolean 控制菜单是否可点击 面板字段参考 字段名 类型 简介 main String 面板入口文件 可以使js也可以是html 取决于type type 为 simple时读取html,否则读入js type String 面板类型 title String 面板标题，如果面板类型为 dockable，面板标题将会显示在 Tab 上。 icon String 面板 Tab 上显示的图标 resizable Boolean 设置面板在独立窗口状态下时是否可以改变大小 width Interger 设置面板窗口的初始宽度 height Interger 设置面板窗口的初始高度 min-widtg Interger 设置面板窗口的最小宽度 min-height Interger 设置面板窗口的最小高度 max-width Interger 设置面板窗口的最大宽度 max-height Interger 设置面板窗口的最大高度 面板type类型 dockable：该面板为标准的编辑器面板，可以自由的在编辑器内停靠。 float：该面板为浮动面板，不能停靠在编辑器中。 fixed-size：该面板和浮动面板功能相似，不同之处在于他的窗口大小是固定的。 quick：该面板和浮动面功能相似，不同之处在于当他失去焦点后将会自动关闭。 simple：简单面板拥有独立窗口，通过读取用户自定义的 html 文件展示界面。 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"CocosCreator学习/编辑器扩展/1.扩展包的安装与结构.html":{"url":"CocosCreator学习/编辑器扩展/1.扩展包的安装与结构.html","title":"1.扩展包的安装与结构","keywords":"","body":" 扩展包的结构与安装 一.扩展包安装与卸载 全局扩展包安装 项目扩展包安装 卸载 二.目录结构 扩展包的结构与安装 一.扩展包安装与卸载 全局扩展包安装 CocosCreator安装目录.CocosCreator\\packages 项目扩展包安装 项目路径.CocosCreator\\packages 卸载 直接从packages删除扩展包目录即可 二.目录结构 MyProject |--assets |--packages |--插件名称 |--package.json |--main.js var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"CocosCreator学习/编辑器扩展/2.扩展包结构与参数解析.html":{"url":"CocosCreator学习/编辑器扩展/2.扩展包结构与参数解析.html","title":"2.扩展包结构与参数解析","keywords":"","body":" 扩展包结构与参数解析 创建并安装扩展包 package.json参数解析 入口程序 - [生命周期](#生命周期) 扩展包结构与参数解析 创建并安装扩展包 创建如下结构的目录结构 放入项目的packages文件夹下 hello-world |--main.js |--package.json package.json参数解析 { \"name\": \"hello-world\", \"version\": \"0.0.1\", \"description\": \"一份简单的扩展包\", \"author\": \"Cocos Creator\", \"main\": \"main.js\", \"main-menu\": { \"Packages/Hello World\": { \"message\": \"hello-world:say-hello\" } } } 参数 介绍 name String-扩展包名称(必须),保证全局唯一性 version String-扩展包的版本号(必须) description String-扩展包的描述(可选) author String-作者(可选) main String-入口程序(可选) main-menu Object-主菜单定义 在编辑器的主菜单显示相应按钮(可选)参考主菜单字段参考 panel Obejct 用于注册开发面板参考panel字段参考 reload Obejct 定制扩展包自动重载的文件监控规则 runtime-resource Obejct 资源映射,将扩展的资源映射到资源管理器 scene-script Obejct 字段用于声明一个扩展包内的脚本，在该脚本中可以使用引擎 API，并访问当前场景中的节点和组件。调用引擎API和项目脚本 范例: runtime-resource 资源映射 \"runtime-resource\": { \"path\": \"path/to/runtime-resource\", \"name\": \"shared-resource\" } 上述声明会将 projectPath/packages/myPackage/path/to/runtime-resource 路径下的全部资源都映射到资源管理器中，显示为 [myPackage]-[shared-resource]。 main-menu 扩展菜单路径 { \"main-menu\": { \"Examples/FooBar\": { \"message\": \"my-package:foo\" }, \"Examples/FooBar/Bar\": { \"message\": \"my-package:bar\" } } } 在这个例子中，我们先在主菜单中注册了一份菜单路径 Examples/Foobar，这之后我们又注册了 Examples/Foobar/Bar，而第二个菜单路径的注册要求 Foobar 的类型为一个分级子菜单（submenu），然而由于上一次的注册已经将 Foobar 的类型定义为菜单选项（menu-item），从而导致了注册失败。 panelpanel (Object) 用于面板注册。面板注册的键值（Key）是一个以 panel 开头的字符串，字符串后面可跟上后缀名用于多面板的注册。注册完成的面板，将会生成以 ${包名}${面板后缀名} 为组合的面板 ID。通常情况下如果我们只注册一个面板，就不需要带后缀名，面板 ID 默认就是插件包的名字。但如果是注册多个面板，就需要带后缀名，以便区分。关于多面板注册，这里我们提供了一个简单的例子，在 package.json 中： { \"name\": \"simple-package\", \"panel\": { \"main\": \"panel/index.js\", \"type\": \"dockable\", \"title\": \"Simple Panel\", \"width\": 400, \"height\": 300 }, \"panel.02\": { \"main\": \"panel.02/index.js\", \"type\": \"dockable\", \"title\": \"Simple Panel 02\", \"width\": 400, \"height\": 300 }, } 入口程序 初始化扩展包 执行后台操作程序 调用CocosCreator主进程中的方法 管理扩展面板的开启和关闭 简单范例 'use strict'; module.exports = { load () { Editor.log('package loaded'); }, unload () { Editor.log('package unloaded'); }, }; 生命周期 load当扩展包正确载入后，将会执行用户入口程序中的 load 函数。我们可以在这里做一些关于扩展包本身的初始化操作。 unload当扩展包卸载进行到最后阶段，将会执行用户入口程序中的 unload 函数。我们可以在这里做一些扩展包卸载前的清理操作。 加载和卸载注意事项Cocos Creator 支持在编辑器运行时动态的添加和删除扩展包，所以要注意如果扩展包依赖编辑器其他模块的特定工作状态时，必须在 load 和 unload 里进行妥善处理。如果插件的动态加载和卸载导致其他模块工作异常时，扩展包的用户总是可以选择关闭编辑器后重新启动。 IPC 消息注册在入口程序中添加 messages 字段，可以让扩展包在加载的时候进行主进程的 IPC 消息注册。样例如下： 'use strict'; module.exports = { messages { 'foo-bar' ( event ) { Editor.log('hello foobar'); }, 'scene:saved' ( event ) { Editor.log('scene saved!'); }, }, }; var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"CocosCreator学习/编辑器扩展/3.进程间的通讯.html":{"url":"CocosCreator学习/编辑器扩展/3.进程间的通讯.html","title":"3.进程间的通讯","keywords":"","body":" 进程间通信 一. 发送消息 主进程向面板panel发送消息 面板向主进程发送消息 其他消息发送方法 二. 接收消息 面板渲染进程消息监听 主进程消息监听 其他消息监听方式 三. 向消息来源发送回调 四. 消息超时处理 进程间通信 参考IPC简介 一. 发送消息 主进程向面板panel发送消息 Editor.Ipc.sendToPanel('panelID', 'message' [, ...args, callback, timeout]) 参数： panelID面板的ID 对于单面板扩展包来说 就是插件的包名 message是 IPC 消息的全名，如 do-some-work，我们推荐在定义 IPC 消息名时使用 - 来连接单词，而不是使用驼峰或下划线。 args可选从第三个参数开始，可以定义数量不定的多个传参，用于传递更具体的信息到面板进程。 callback可选 在传参后面可以添加回调方法，在面板进程中接受到 IPC 消息后可以选择向主进程发送回调，并通过 callback 回调方法进行处理。回调方法的参数第一个是 error（如果没有错误则传入 null），之后才是传参。 timeout 可选回调超时，只能配合回调方法一起使用，如果规定了超时，在消息发送后的一定时间内没有接到回调方法，就会触发超时错误。如果不指定超时，则默认的超时设置是 5000 毫秒。 面板向主进程发送消息 Editor.Ipc.sendToMain('message', [, ...args, callback, timeout]) 其他消息发送方法 任意进程对主进程Editor.Ipc.sendToMain 任意进程对面板Editor.Ipc.sendToPanel 任意进程对编辑器主窗口（也就是对主窗口里的所有渲染进程广播）Editor.Ipc.sendToMainWin 任意进程对所有窗口（对包括弹出窗口在内的所有窗口渲染进程广播）Editor.Ipc.sendToWins 任意进程对所有进程广播Editor.Ipc.sendToAll 二. 接收消息 要在主进程或渲染进程中接受 IPC 消息，最简单的办法是在声明对象的 messages 字段中注册以 IPC 消息为名的消息处理方法。 面板渲染进程消息监听 Editor.Panel.extends({ //... messages: { 'my-message': function (event, ...args) { //do some work } } }); 主进程消息监听 module.exports = { //... messages: { 'my-message': function (event, ...args) { //do some work } } } 其他消息监听方式 渲染进程中： require('electron').ipcRenderer.on('foobar:message', function(event, args) {}); 主进程中： require('electron').ipcMain.on('foobar:message', function(event, args) {}); 三. 向消息来源发送回调 假如我们从主进程发送了一个消息： //packages/foobar/main.js Editor.Ipc.sendToPanel('foobar', 'greeting', 'How are you?', function (error, answer) { Editor.log(answer); }); 在面板监听消息的方法中，我们可以使用 event.reply 来发送回调： Editor.Panel.extends({ //... messages: { 'greeting': function (event, question) { console.log(question); //How are you? if (event.reply) { //if no error, the first argument should be null event.reply(null, 'Fine, thank you!'); } } } }); 四. 消息超时处理 Editor.Ipc.sendToMain('foobar:greeting', function (error, answer) { if ( error && error.code === 'ETIMEOUT' ) { //check the error code to confirm a timeout Editor.error('Timeout for ipc message foobar:greeting'); return; } Editor.log(answer); }); var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"CocosCreator学习/编辑器扩展/4.调用引擎API和项目脚本.html":{"url":"CocosCreator学习/编辑器扩展/4.调用引擎API和项目脚本.html","title":"4.调用引擎API和项目脚本","keywords":"","body":" 调用引擎 API 和项目脚本 注册场景脚本 编写场景脚本 扩展包向场景脚本发送消息 调用引擎 API 和项目脚本 在插件中可以声明一个特殊的脚本文件（场景脚本），该脚本和项目中的脚本 （assets 目录下的脚本）具有相同的环境，也就是说在这个脚本里可以调用引擎 API 和其他项目脚本，实现 遍历场景中的节点，获取或改动数据 调用项目中的其他脚本完成工作 注册场景脚本 package.json的 scene-script 字段 \"scene-script\": \"scene-walker.js\" 编写场景脚本 module.exports = { 'get-canvas-children': function (event) { var canvas = cc.find('Canvas'); Editor.log('children length : ' + canvas.children.length); if (event.reply) { event.reply(null, canvas.children.length); } } }; 扩展包向场景脚本发送消息 Editor.Scene.callSceneScript('foobar', 'get-canvas-children', function (err, length) { console.log(`get-canvas-children callback : length - ${length}`); }); var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"CocosCreator学习/编辑器扩展/":{"url":"CocosCreator学习/编辑器扩展/","title":"编辑器扩展","keywords":"","body":" MarkdownNotes 介绍 个人笔记记录 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"CocosCreator学习/网络连接/1.短链接.html":{"url":"CocosCreator学习/网络连接/1.短链接.html","title":"1.短链接","keywords":"","body":" 短链接 简单使用 封装的网络请求代码 短链接 简单使用 let xhr = new XMLHttpRequest(); xhr.onreadystatechange = function () { if (xhr.readyState == 4 && (xhr.status >= 200 && xhr.status 封装的网络请求代码 let TAG = 'NetWork' export const EnumNetworkError = { kNetworkErrorTimeout: 'kNetworkErrorTimeout', kNetworkErrorAbort: 'kNetworkErrorAbort', kNetworkErrorError: 'kNetworkErrorError', } export const EnumEncryType = { EnumEncryTypeNone: 'EnumEncryTypeNone', EnumEncryTypeAES: 'EnumEncryTypeAES' } export const NetWork = (function () { let object = new Object(); /** * url 请求地址 * reqData 请求的数据 * reqType http的请求方法 */ object.request = function ({ url = '', reqData = {}, reqType = 'POST', async = true, callback = null, errorCallback = null, encryType = EnumEncryType.EnumEncryTypeNone } = {}) { let params = ''; for (let key in reqData) { params += (key + '=' + reqData[key] + '&') } console.log(TAG, 'url: ' + url + ' params: ' + params); // return; let xhr = new XMLHttpRequest(); xhr.onreadystatechange = function () { console.log(TAG, 'readyState: ' + xhr.readyState + ' status: ' + xhr.status + ' statusText: ' + xhr.statusText); // 0：请求未初始化（还没有调用 open()）。 // 1：请求已经建立，但是还没有发送（还没有调用 send()）。 // 2：请求已发送，正在处理中（通常现在可以从响应中获取内容头）。 // 3：请求在处理中；通常响应中已有部分数据可用了，但是服务器还没有完成响应的生成。 // 4：响应已完成；您可以获取并使用服务器的响应了。 if (xhr.readyState == 4) { if (xhr.status == 200) {// 响应中的数字状态码：表示为有效响应，成功的请求 var response = xhr.responseText; if (response) { console.log(TAG, 'response:' + response); if (callback && typeof callback === 'function') { callback(response); } } else { console.log(TAG, 'no response data'); } } else { //失败 console.log(TAG, 'request url: ' + url + 'fail' + ' status: ' + xhr.status + ' statusText: ' + xhr.statusText); if (errorCallback && typeof errorCallback === 'function') { errorCallback(xhr.statusText); } } } }; xhr.ontimeout = function () { console.log(TAG, 'ontimeout'); if (errorCallback && typeof errorCallback === 'function') { errorCallback(EnumNetworkError.kNetworkErrorTimeout); } } xhr.onabort = function () { console.log(TAG, 'onabort'); if (errorCallback && typeof errorCallback === 'function') { errorCallback(EnumNetworkError.kNetworkErrorAbort); } } xhr.onerror = function () { //出现错误 console.log(TAG, 'onerror'); if (errorCallback && typeof errorCallback === 'function') { errorCallback(EnumNetworkError.kNetworkErrorError); } } xhr.onload = function () { console.log(TAG, 'onload'); } xhr.onloadend = function () { console.log(TAG, 'onloadend'); } xhr.onloadstart = function () { console.log(TAG, 'onloadstart'); } xhr.onprogress = function () { console.log(TAG, 'onprogress'); } if (reqType == \"GET\") { xhr.open(reqType, url + \"?\" + params, async); xhr.setRequestHeader(\"Content-Type\", \"application/x-www-form-urlencoded\"); xhr.send(\"\"); } else if (reqType == \"POST\") { xhr.open(reqType, url, async); xhr.setRequestHeader(\"Content-Type\", \"application/x-www-form-urlencoded\"); xhr.send(params); } } return object; })(); var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"CocosCreator学习/网络连接/2.长连接.html":{"url":"CocosCreator学习/网络连接/2.长连接.html","title":"2.长连接","keywords":"","body":"长连接 WebSocket CocosCreator推荐使用。 简单使用 let ws = new WebSocket(\"ws://echo.websocket.org\"); ws.onopen = function (event) { console.log(\"Send Text WS was opened.\"); }; ws.onmessage = function (event) { console.log(\"response text msg: \" + event.data); }; ws.onerror = function (event) { console.log(\"Send Text fired an error\"); }; ws.onclose = function (event) { console.log(\"WebSocket instance closed.\"); }; setTimeout(function () { if (ws.readyState === WebSocket.OPEN) { ws.send(\"Hello WebSocket, I'm a text message.\"); } else { console.log(\"WebSocket instance wasn't ready...\"); } }, 3); 自己封装的工具类(未完成版本,后续优化) let instance = Symbol(\"instance\"); let socket = Symbol(\"socket\"); export class WebSocketUtils { constructor() { } static getInstance() { if (this[instance] == null) { this[instance] = new WebSocketUtils(); } return this[instance]; } connect(url) { if (this[socket] == null) { this[socket] = new WebSocket(url); this[socket].binaryType = \"arraybuffer\"; this[socket].onopen = this.onOpen.bind(this); this[socket].onmessage = this.onMessage.bind(this); this[socket].onclose = this.onClose.bind(this); this[socket].onerror = this.onError.bind(this); // this[socket].addEventListener('open', function (event) { // console.log(WebSocketUtils.name + \" onOpe2\"); // }); // this[socket].addEventListener('open', function (event) { // console.log(WebSocketUtils.name + \" onOpen3\"); // }); } else { this.close(); } } onOpen() { console.log(WebSocketUtils.name + \" onOpen\"); } onMessage(message) { console.log(WebSocketUtils.name + \" onMessage\", message); } onClose() { console.log(WebSocketUtils.name + \" onClose\"); this.close(); } onError(message) { console.log(WebSocketUtils.name + \" OnError\", message); this.close(); } close() { if (this[socket]) { this[socket].close(); this[socket] = null; } } sendData(message) { try { this[socket].send(message); } catch (error) { console.log(WebSocketUtils.name + \"sendData\" + error); } } } SocketIO cocoscreator 不支持此方法，用户需要根据平台自己添加 目前本人只完成了js版本，其他平台版本后续更新 import { Facade } from \"../Facade\"; export const SOCKET_ERROR = { SOCKET_ERROR_DISCONNET: \"SOCKET_ERROR_DISCONNET\",//连接断开 SOCKET_ERROR_SOCKET_NOT_NULL: \"SOCKET_ERROR_SOCKET_NOT_NULL\",// }; Object.freeze(SOCKET_ERROR); export const SOCKET_EVENT = { SOCKET_EVENT_CONNECT: \"SOCKET_EVENT_CONNECT\",//连接成功 SOCKET_EVENT_DISCONNECT: \"SOCKET_EVENT_DISCONNECT\",//连接断开 SOCKET_EVENT_CONNECT_ERROR: \"SOCKET_EVENT_CONNECT_ERROR\",//连接出现错误 } Object.freeze(SOCKET_EVENT); let symbolSocket = Symbol(\"socket\"); let instance = Symbol(\"instance\"); export class SocketIOUtils { constructor() { //socket实例 this[symbolSocket] = null; } static getInstance() { if (!this[instance]) { this[instance] = new SocketIOUtils(); } return this[instance]; } /** * * @param {String} url 服务器地址 */ connect(url) { if (this[symbolSocket] == null) { this[symbolSocket] = window.io(url, { transports: ['websocket'], 'force new connection': true, }); this[symbolSocket].on(\"connect\", (data) => { console.log(\"SocketIOUtils connect : \" + data); Facade.getInstance().sendNotify(SOCKET_EVENT.SOCKET_EVENT_CONNECT, data) //发送连接成功的事件 }); this[symbolSocket].on(\"disconnect\", (data) => { //发送连接失败的事件 console.log(\"SocketIOUtils disconnect : \" + data); Facade.getInstance().sendNotify(SOCKET_EVENT.SOCKET_EVENT_DISCONNECT, data); this.disConnect(); }); this[symbolSocket].on(\"connect_error\", (data) => { //发送连接错误的事件 console.log(\"SocketIOUtils connectError : \" + data); Facade.getInstance().sendNotify(SOCKET_EVENT.SOCKET_EVENT_CONNECT_ERROR, data); this.disConnect(); }); this[symbolSocket].on(\"chat message\", function (message) { //服务器发来消息 console.log(\"chat message : \" + message); }); } else { console.log(\"disconnect\"); this.disConnect(); } } sendData(data, callback) { try { this[symbolSocket].emit(\"sendMessage\", data, typeof callback === \"function\" ? callback : (message) => { console.log(\"sendData success\" + message); }); } catch (err) { console.log(\"send data error \", err); } // if (this[symbolSocket]) { // }else{ // throw error() // } } /** * 断开连接 */ disConnect() { if (this[symbolSocket]) { this[symbolSocket].close(); this[symbolSocket] = null; } } } socket.io.js var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"CocosCreator学习/网络连接/3.下载.html":{"url":"CocosCreator学习/网络连接/3.下载.html","title":"3.下载","keywords":"","body":"网络下载 自写的工具类 let TAG = 'DownloadUtils'; export class Downloader { constructor() { this.downloader = null; this.taskSuccessCallback = null; this.taskProgressCallback = null; this.taskErrorCallback = null; } downFile({ downUrl = '', savePath = '', saveFileName = '', taskSuccessCallback = null, taskProgressCallback = null, taskErrorCallback = null } = {}) { //创建Savepath let path = jsb.fileUtils.getWritablePath() + savePath; var initDir = jsb.fileUtils.createDirectory(path); if (!initDir) { console.log(TAG, 'initDir fail'); if (this.taskErrorCallback) { this.taskErrorCallback(null, null, null, \"initDir fail\"); } return; } this.downloader = new jsb.Downloader(); this.downloader.setOnFileTaskSuccess(this.onSucceed.bind(this)); this.downloader.setOnTaskProgress(this.onProgress.bind(this)); this.downloader.setOnTaskError(this.onError.bind(this)); if (taskSuccessCallback) { this.taskSuccessCallback = taskSuccessCallback; } if (taskProgressCallback) { this.taskProgressCallback = taskProgressCallback; } if (taskErrorCallback) { this.taskErrorCallback = taskErrorCallback; } this.downloader.createDownloadFileTask(downUrl, path + saveFileName); } onSucceed(task) { this.task = task; if (this.taskSuccessCallback) { this.taskSuccessCallback({ task: task }); } } /** * * @param {*} task * @param {long } bytesReceived 本次接收的数据大小 * @param {long } totalBytesReceived 文件的大小 * @param {long } totalBytesExpected 累计接收的数据大小 */ onProgress(task, bytesReceived, totalBytesReceived, totalBytesExpected) { console.log(TAG, 'bytesReceived:' + bytesReceived + ' totalBytesReceived: ' + totalBytesExpected + ' totalBytesExpected: ' + totalBytesReceived); this.task = task; if (this.taskProgressCallback) { let progress = totalBytesReceived / totalBytesExpected * 100; this.taskProgressCallback({ task: task, bytesReceived: bytesReceived, totalBytesReceived: totalBytesReceived, totalBytesExpected: totalBytesExpected, progress: progress }); } } onError(task, errorCode, errorCodeInternal, errorStr) { this.task = task; let errorStr2 = 'Failed to download file (' + task.requestURL + '): ' + errorStr + '(' + errorCode + ')'; console.log(TAG, errorStr2); if (this.taskErrorCallback) { this.taskErrorCallback({ task: task, errorCode: errorCode, errorCodeInternal: errorCodeInternal, errorStr: errorStr }); } } } var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"CocosCreator学习/网络连接/":{"url":"CocosCreator学习/网络连接/","title":"网络连接","keywords":"","body":" MarkdownNotes 介绍 CocosCreator 网络连接 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"CocosCreator学习/资源管理/1.资源的加载与释放.html":{"url":"CocosCreator学习/资源管理/1.资源的加载与释放.html","title":"1.资源的加载与释放","keywords":"","body":" 资源的加载 加载资源 1. cc.resource.load 2. cc.resource.loadDir 读取文件夹下的资源 3. cc.assetManager.loadRemote( 读取远程资源 4.其他的方式 可查询官方APi 资源释放 cc.assetManager.releaseAsset(asset: cc.Asset) cc.loader.releaseAll 5. 预加载 资源的加载 2.4.3以后 使用Bundle来进行资源加载 export var resources: AssetManager.Bundle 加载资源 1. cc.resource.load /* @params paths 文件的路径 或者 文件路径的数组 当传入的为数组是,返回的是assets的数组 @params type 资源的类型 常用的包括cc.SpriteFrame cc.Texture2d 等具体可查阅官方api @params onProgress 进度函数 @params onComplete (error assets) error 未发生错误 error为null assets为单个cc.Asset或者cc.Asset的数组 */ load(paths: string, type: typeof cc.Asset, onProgress: (finish: number, total: number, item: RequestItem) => void, onComplete: (error: Error, assets: T) => void): void; load(paths: string[], type: typeof cc.Asset, onProgress: (finish: number, total: number, item: RequestItem) => void, onComplete: (error: Error, assets: Array) => void): void; load(paths: string, onProgress: (finish: number, total: number, item: RequestItem) => void, onComplete: (error: Error, assets: T) => void): void; load(paths: string[], onProgress: (finish: number, total: number, item: RequestItem) => void, onComplete: (error: Error, assets: Array) => void): void; load(paths: string, type: typeof cc.Asset, onComplete?: (error: Error, assets: T) => void): void; load(paths: string[], type: typeof cc.Asset, onComplete?: (error: Error, assets: Array) => void): void; load(paths: string, onComplete?: (error: Error, assets: T) => void): void; load(paths: string[], onComplete?: (error: Error, assets: Array) => void): void; 2. cc.resource.loadDir 读取文件夹下的资源 /* @params dir 文件夹的路径 @params type 资源的类型 不填则是读取所有类型的资源 @params onProgress 进度函数 @params onComplete (error assets) error 未发生错误 error为null assets为cc.Asset的数组 */ loadDir(dir: string, type: typeof cc.Asset, onProgress: (finish: number, total: number, item: RequestItem) => void, onComplete: (error: Error, assets: Array) => void): void; loadDir(dir: string, onProgress: (finish: number, total: number, item: RequestItem) => void, onComplete: (error: Error, assets: Array) => void): void; loadDir(dir: string, type: typeof cc.Asset, onComplete: (error: Error, assets: Array) => void): void; loadDir(dir: string, type: typeof cc.Asset): void; loadDir(dir: string, onComplete: (error: Error, assets: Array) => void): void; loadDir(dir: string): void; 3. cc.assetManager.loadRemote( 读取远程资源 /* @params url 远程地址 @params options @params onComplete @example cc.assetManager.loadRemote('http://www.cloud.com/test1.jpg', (err, texture) => console.log(err)); cc.assetManager.loadRemote('http://www.cloud.com/test2.mp3', (err, audioClip) => console.log(err)); cc.assetManager.loadRemote('http://www.cloud.com/test3', { ext: '.png' }, (err, texture) => console.log(err)); */ loadRemote(url: string, options: Record, onComplete: (err: Error, asset: T) => void): void; loadRemote(url: string, onComplete: (err: Error, asset: T) => void): void; loadRemote(url: string, options: Record): void; loadRemote(url: string): void; 4.其他的方式 可查询官方APi loadScene getInfoWithPath getDirWithPath 资源释放 cc.assetManager.releaseAsset(asset: cc.Asset) 释放单个资源 cc.loader.releaseAll 释放所有资源 慎用 5. 预加载 大部分加载接口都有与之对应的预加载方法 preload preloadDir preloadScene 预加载和加载的区别： 预加载只会下载资源 但是不会解析资源和初始化 预加载的在加载过程中 收到的限制更多，比如下载同时并发数更小 预加载的下载优先级更低，一般是放在最后下载 预加载由于没有做任何解析，不会返回任何可用资源 因为预加载没有去解析资源，所以需要在预加载完成后配合加载接口进行资源的解析和初始化，来完成资源加载。例如： cc.resources.preload('images/background', cc.SpriteFrame); // wait for while cc.resources.load('images/background', cc.SpriteFrame, function (err, spriteFrame) { spriteFrame.addRef(); self.getComponent(cc.Sprite).spriteFrame = spriteFrame; }); 注意加载 不需要等待 预加载完成即可使用 ， 加载只是会直接复用预加载已经下载好的内容 从而缩短下载事件而已 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"CocosCreator学习/资源管理/2.AssetBundle详解.html":{"url":"CocosCreator学习/资源管理/2.AssetBundle详解.html","title":"2.AssetBundle详解","keywords":"","body":" AssetBundle 1.内置 Bundle 2. 加载内置的Asset Bundle 3.优先级 4.Asset Bundle 构造 AssetBundle 从 v2.4 开始，Creator 正式支持 Asset Bundle 功能用于 减少启动时需要加载的资源量 减少首次下载和加载APP所需的事件 1.内置 Bundle V2.4开始 项目所有的资源会放到Creator内置的4个AssetBundle中 内置AssetBundle 功能 配置 internal 存放所有内置资源以及依赖资源 通过配置internal中的resource文件夹目前不支持修改默认配置 main 存放参与构建的场景以及场景依赖的资源 通过构建发布面板的主包压缩类型和配置主包为远程包两项 resource 存放在resources目录下的所有资源及其依赖项 通过配置assets->resources文件夹 start-scene 在构建面板中勾选了初始场景分包 首场景将会被构建到start-scene中 不可配置 2. 加载内置的Asset Bundle 如果是资源放在了服务器上 两种方式 通过构建发布 配置面板 配置 资源服务器地址 自定义构建模板 main.js实例代码 ```js let bundleRoot = []; // 加入 internal bundle 的 URL 地址 bundleRoot.push('http://myserver.com/assets/internal'); // 如果有 resources bundle, 则加入 resources bundle 的 URL 地址 bundleRoot.push('http://myserver.com/assets/resources'); // 加入 main bundle 的 URL 地址 bundleRoot.push('http://myserver.com/assets/main'); var count = 0; function cb (err) { if (err) { return console.error(err.message, err.stack); } count++; if (count === bundleRoot.length + 1) { cc.game.run(option, onStart); } } cc.assetManager.loadScript(settings.jsList.map(x => 'src/' + x), cb); for (let i = 0; i ### 3.优先级 1. 文件夹设为Asset Bundle后 会将**文件夹中的资源**和**文件夹外的依赖资源**合并到一个Asset Bundle中,这可能会出现 某一资源不在Asset Bundle的文件中 却同时 被 多个Asset Bundle 所依赖 2. 在某一Asset Bundle中的资源 同时又被另一个Asset Bundle所依赖 解决以上问题 就需要调整Asset Bundle的**优先级** * 当同一资源被**不同优先级的**Asset Bundle引用时，资源会优先放在**优先级等级高**的Asset Bundle中，**低优先级的** 只会 保留一条存储记录。 如果你想在**低优先级的Asset Bundle**中加载共享资源 **必须在之前加载高优先级的Asset Bundle.** * 当同一资源被**同一优先级**的Asset Bundle引用时，资源在每个Asset Bundle中都会复制一份，不同的Asset Bundle之间没有依赖关系 **注意** 所以请尽量确保共享的资源所在的 Asset Bundle 优先级更高，以便让更多低优先级的 Asset Bundle 共享资源，从而最小化包体。 四个内置 Asset Bundle 文件夹的优先级分别为： |Asset Bundle|优先级| |:--|:--| internal|11 main|7 resources|8 start-scene|9 ### 4.Asset Bundle 构造 . ├── config.json ├── import ├── index.js └── native * 代码 文件夹中的所有代码会根据发布平台 合成一个 index.js 或者 game.js 的入口文件，并从主包中剔除。 * 资源 **文件夹中的所有资源**和**依赖的外部资源** 会放到`import`或者`native`文件夹中。 * 资源配置 所有资源的配置信息包括路径，类型，版本 都会被合并到一个 `config.json`文件中。 ```json { \"paths\": { \"714W4sbRJFoKZ+Df2RJjTD\": [ \"images/HelloWorld\", \"cc.SpriteFrame\", 1 ], }, \"uuids\": [ \"714W4sbRJFoKZ+Df2RJjTD\", ], \"scenes\": { \"db://assets/bundleTest/Scene/bundleTestScene.fire\": \"c5TnrcxWBBoJ0SbNZ1AZsz\" }, \"name\": \"bundleTest\", \"importBase\": \"import\", \"nativeBase\": \"native\", \"debug\": true, \"isZip\": false, \"encrypted\": false } var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"CocosCreator学习/资源管理/3.下载和解析.html":{"url":"CocosCreator学习/资源管理/3.下载和解析.html","title":"3.下载和解析","keywords":"","body":" Asset Manager 下载和解析 下载器cc.assetManager.downloader 其他参数设置 解析器 cc.assetManager.parse 可选参数设置 预设 Asset Manager 下载和解析 Asset Manager 底层使用了多条加载管线来加载和解析资源开发者可以通过 cc.assetManager.downloader 下载器 和 cc.assetManager.parser 解析器 来访问。 下载器cc.assetManager.downloader 全图单例模式 使用了一个 jsb.Downloader 类的实例，用于在 原生平台 从服务器上下载资源。jsb.Downloader 与 Web 的 XMLHttpRequest 类似。目前 jsb.Downloader 类的实例的下载并发数限制默认为 32，超时时长默认为 30s，如果需要修改默认值，可以在 main.js 中修改： //main.js cc.assetManager.init({ bundleVers: settings.bundleVers, remoteBundles: settings.remoteBundles, server: settings.server, jsbDownloaderMaxTasks: 32, // 最大并发数 jsbDownloaderTimeout: 60 // 超时时长 }); 其他参数设置 下载重试次数cc.assetManager.downloader.maxRetryCount = 0; 下载重试间隔cc.assetManager.downloader.retryInterval = 4000; 下载并发数 用于设置下载的最大并发连接数，若当前连接数超过限制，将会进入等待队列。 cc.assetManager.downloader.maxConcurrency = 10; 每帧发起的最大请求数 设置每帧发起的最大请求数，从而均摊发起请求的 CPU 开销，避免单帧过于卡顿。如果此帧发起的连接数已经达到上限，将延迟到下一帧发起请求。 cc.assetManager.downloader.maxRequestsPerFrame = 6; 解析器 cc.assetManager.parse 解析器用于将文件解析为引擎可识别的资源，开发者可以通过 cc.assetManager.parser 来访问。 可选参数设置 在下载器和解析器中的设置都是全局设置，若开发者需要单独设置某个资源，可以通过 可选参数 传入专有设置来覆盖全局设置，例如： cc.assetManager.loadAny({'path': 'test'}, {priority: 2, maxRetryCount: 1, maxConcurrency: 10}, callback); 下载器和解析器的可选参数 名称 功能 priority|优先级 maxConcurrency|下载并发限制 maxRequestsPerFrame|每帧发起的请求次数 maxRetryCount|最大的重试次数 控制下载器和解析器的处理方法 名称 功能 responseType|返回类型 withCredentials|资质证书 mimeType|媒体类型 timeout|最大的重试次数 header|头部 onFileProgress|进度函数 audioLoadMode|用于控制音频文件的处理方法是否使用 WebAudio 来加载 // 获取 XHR 的下载进度回调 cc.assetManager.loadAny({'path': 'image/background'}, {onFileProgress: function (loaded, total) { console.log(loaded/total); }}, callback); // 使用 WebAudio 远程加载音频 cc.assetManager.loadRemote('http://example.com/background.mp3', {audioLoadMode: cc.AudioClip.LoadMode.WEB_AUDIO}, callback); 控制加载流程 名称 功能 reload|是否复用缓存中的资源 cacheAsset|是否缓存资源 cacheEnabled|是否缓存文件 uuid, url, path, dir, scene, type, ext, bundle|主要用于搜索医院 cc.assetManager.loadRemote(url, {reload: true, cacheAsset: false, cacheEnabled: true}, (err, asset) => {}); 预设 Creator 预先对正常加载、预加载、场景加载、Asset Bundle 加载、远程资源加载、脚本加载这 6 种加载情况的下载/解析参数做了预设，其中预加载因为性能考虑，所以限制较大，最大并发数更小。如下所示： { 'default': { priority: 0, }, 'preload': { maxConcurrency: 2, maxRequestsPerFrame: 2, priority: -1, }, 'scene': { maxConcurrency: 8, maxRequestsPerFrame: 8, priority: 1, }, 'bundle': { maxConcurrency: 8, maxRequestsPerFrame: 8, priority: 2, }, 'remote': { maxRetryCount: 4 }, 'script': { priority: 2 } } 开发者可以通过 cc.assetManager.presets对每种预设进行修改，使用时需要传入预设的名称来访问对应的参数项。 // 修改预加载的预设优先级为 1 let preset = cc.assetManager.presets.preload; preset.priority = 1; 也可以增加自定义预设，并通过可选参数 preset 传入。 cc.assetManager.presets.mypreset = {maxConcurrency: 10, maxRequestsPerFrame: 6}; cc.assetManager.loadAny({'path': 'test'}, {preset: 'mypreset'}, callback); var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"CocosCreator学习/资源管理/4.缓存管理.html":{"url":"CocosCreator学习/资源管理/4.缓存管理.html","title":"4.缓存管理","keywords":"","body":"缓存管理 cc.assetManager.cacheManager 查询缓存文件和临时文件 cc.resources.load('images/background', cc.Texture2D, function (err, texture) { var cachePath = cc.assetManager.cacheManager.getCache(texture.nativeUrl); console.log(cachePath); }); cc.assetManager.loadRemote('http://example.com/background.jpg', function (err, texture) { var tempPath = cc.assetManager.cacheManager.getTemp(texture.nativeUrl); console.log(tempPath); }); cc.assetManager.cacheManager 参数 cacheDir控制缓存资源的存储目录。 cacheInterval控制缓存单个资源的周期，默认 500ms 缓存一次。 cachedFiles所有缓存文件列表if (cc.assetManager.cacheManager.cachedFiles) { cc.assetManager.cacheManager.cachedFiles.forEach((val, key) => { if (val.bundle && val.bundle === \"bundleTest\") { console.log(JSON.stringify(val)); cc.assetManager.cacheManager.removeCache(key); } }); } 清理缓存 removeCache清理单个缓存资源，使用时需要提供资源的原路径cc.assetManager.loadRemote('http://example.com/background.jpg', function (err, texture) { cc.assetManager.cacheManager.removeCache(texture.nativeUrl); }); clearCache清理所有缓存资源，请慎重使用。 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"CocosCreator学习/资源管理/":{"url":"CocosCreator学习/资源管理/","title":"资源管理","keywords":"","body":"资源管理笔记 关于CocosCreator的管理笔记 版本 2.4.3 及 以上 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"JavaScript学习/RegExp正则表达式.html":{"url":"JavaScript学习/RegExp正则表达式.html","title":"RegExp正则表达式","keywords":"","body":" 正则表达式(RegExp) 一.创建 二.正则表达式的属性和模式 属性 模式 三.正则表达式的3个方法 四.正则表达式基础 1. 直接量字符 2. 字符类 3.方括号的使用方法 4.量词 (重复字符语法 非贪婪重复) 练习 正则表达式(RegExp) 一.创建 //使用RegExp的构造函数来创建 let regExpA= new RegExp('abc'); //使用 / /语法创建 let regExpB = /abc/; 二.正则表达式的属性和模式 属性 属性 描述 global 返回布尔值，表示是否设置了g修饰符 ignoreCase 返回布尔值,表示是否设置了i修饰符 lastIndex 返回下一次搜索的位置 multiline 返回布尔值，表示是否设置了m修饰符 source 返回正则表达式的字符串形式(不包含反斜杠) 注意: lastIndex为可读写属性，其他均为只读属性 模式 模式 描述 g 默认情况下 第一次匹配成功后 正则表达式停止向下匹配 g表示全局匹配 加上以后将匹配所有符合条件的结果 i 默认情况下区分大小写 i表示忽略大小写 m m修饰符表示多行模式 会忽略字符创的头部或者尾部的换行符 三.正则表达式的3个方法 test() 检索字符串中的指定值,返回类型为布尔值 exec() 检索字符串中的指定值,返回一个数组,没有则返回null compile() 修改正则表达式let a = /abc/ig let string1 = \"123ABC21ABC23\"; console.log(a.test(string1));//检测字符串中的指定值,返回为布尔值 console.log(a.exec(string1));//检测字符创中的指定值,返回数组 /* true, [ 'ABC', index: 8, input: '123ABC21ABC23', groups: undefined ] */ 四.正则表达式基础 1. 直接量字符 字符 匹配 \\o 查找null字符 \\n 换行符 \\f 换页符 \\r 回车符 \\t 制表符 \\v 垂直制表符 \\xxx 八进制的字符 \\xdd 十六进制数dd规定的字符 \\uxxx Unicode 2. 字符类 字符 匹配 . 查找单个字符，除了换行和行结束符 [...] 方框内的任意符 ... 不在方框内的任意字符 \\w 单词字符 \\W 非单词字符 \\d 数字字符 \\D 非数字字符 \\s 空白字符 \\S 非空白字符 \\b 匹配单词边界 \\B 匹配非单词边界 3.方括号的使用方法 示例 表达式 描述 [abc] 查找方框内的任何字符 [ ^abc ] 不在方框内的任意字符 [0-9] 查找0-9的数字 [a-z] 小写a到小写z之间的所有字符 [A-Z] 大写A到大写Z之间的所有字符 [A-z] 大写A到小写z之间的所有字符 4.量词 (重复字符语法 非贪婪重复) 量词 描述 n+ 匹配至少含有一个n的字符串 n* 任何包含0或者多个n的字符串 n? 任何包含0个或一个n的字符串 n{X} 包含X个n的字符串 n{X,Y} 包含X到Y个n的字符串 n(X,) 至少包含X个n的字符串 (?=n) 匹配任意后面紧跟n的字符串 (?!n) 匹配任意后面不紧跟n的字符串 练习 // 手机号匹配 let phoneNUms = \"18730870726 1761345689 18730870729 dsfsdfds 193488588696 135777777777777\"; let phoneNumRegRxp = /(1{1}[3|5|8]\\d{9}(?= ))/gm console.log(phoneNUms.match(phoneNumRegRxp)); /* [ '18730870726', '18730870729' ] */ //子表达式 let s = \"titletext\"; let r = /()\\w*\\1/g console.log(s.match(r)); /* [ 'title', 'text' */ //屏蔽词 let biWords = [\"王八蛋\", \"傻逼\", \"Fuck\"]; let regStr = \"(\" + biWords.join(\")|(\") + \")\"; console.log(regStr); let regRxpBi = new RegExp(regStr, \"gi\"); console.log(\"你个王八蛋，臭傻逼\".replace(regRxpBi, \"*\")); /* (王八蛋)|(傻逼)|(Fuck) 你个*，臭* */ var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"JavaScript学习/":{"url":"JavaScript学习/","title":"JavaScript学习","keywords":"","body":" JavaScript学习记录 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"JavaScript学习/ES6/":{"url":"JavaScript学习/ES6/","title":"ES6","keywords":"","body":"ES6 参考地址 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Markdown使用方法/":{"url":"Markdown使用方法/","title":"Markdown使用方法","keywords":"","body":" 说明 Markdown 的使用方法 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Markdown使用方法/Markdown绘图指南/":{"url":"Markdown使用方法/Markdown绘图指南/","title":"Markdown绘图指南","keywords":"","body":"Markdown绘图指南 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Solitaire项目笔记/":{"url":"Solitaire项目笔记/","title":"Solitaire项目笔记","keywords":"","body":"Introduction Solitaitr项目概况 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Solitaire项目笔记/项目概况/":{"url":"Solitaire项目笔记/项目概况/","title":"项目概况","keywords":"","body":"Introduction Solitaitr项目笔记 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Solitaire项目笔记/项目概况/1.项目初探/":{"url":"Solitaire项目笔记/项目概况/1.项目初探/","title":"1.项目初探","keywords":"","body":"Introduction Solitaitr项目笔记 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Solitaire项目笔记/项目概况/2.UI绘制/1.creator界面的使用.html":{"url":"Solitaire项目笔记/项目概况/2.UI绘制/1.creator界面的使用.html","title":"1.creator界面的使用","keywords":"","body":"creato界面的使用 git工程 项目名称：solitaire_ui项目分支：ui_work creator版本：2.3.2 UI界面 如何拼接面不在赘述。 build 项目->UIEditor->Build Now生成 .ccreator文件。 使用 cc.spriteFrameCache.addSpriteFrames(\"ui/ui_button.plist\"); cc.spriteFrameCache.addSpriteFrames(\"change_apk/change_apk.plist\"); // 使用前需要自己加载资源 creator.CreatorReader.createWithFilename(\"change_apk/message.ccreator\"); 注意使用前需要自己加载资源,使用完成后记得从内存中清除资源要使用pvr类型的资源，关于pvr资源的生成详见参考这个文档 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Solitaire项目笔记/项目概况/2.UI绘制/2.基本界面的创建.html":{"url":"Solitaire项目笔记/项目概况/2.UI绘制/2.基本界面的创建.html","title":"2.基本界面的创建","keywords":"","body":"基本的类型 Scene继承cc.Scene具体方法查看官方api Node继承cc.Node具体方法查看官方api Layer继承cc.Laye具体方法查看官方api 自己封装的UI类 MessageLayer 参考msg目录弹出层界面的基类，用于绘制弹出层 1.常用方法 setPriority设置显示优先级，优先级越低 ，越优先显示 setValidBgSize设置bg层的大小，点击到bg范围外时将自动关闭弹窗。 setValidBgX设置bg层x坐标 setValidBgY设置bg层的y坐标 showEnterAction弹出的动画 onPopActionEnd弹出动画完成后的回调 showDisappearEffect关闭界面 有动画 disact关闭界面 无动画 2.绘制调用 通过MessageLayerMgr的showMessage方法来显示 let layer = new MsgCoinRechargeLayer(); MessageLayerMgr.getInstance().showMessage(layer, true); TransitionNode Scene转场时的基类 在transition目录下 1.方法 ctor在子类的构造函数里初始化下个scene要用到的资源。 SpriteFrame this._frames 音效资源 this._music 图片资源 this._image 骨骼动画资源 this._spines this._super(parent)发在初始化资源之后。 replaceScene资源的加载会在基类中完成，具体实现看基类的具体方法，资源加载完成后，会调用此方法，在此方法里写转场代码。 replaceScene: function () { var scene = new HomeScene(); scene.setName(\"HomeScene\"); cc.director.replaceScene(scene); } 常用的屏幕数据 display.js 用于屏幕适配的计算 基本参数 display.sw屏幕的宽 display.sh屏幕的高 display.size屏幕安全区的大小 display.width屏幕安全区的宽 display.height屏幕安全区的高 display.cx屏幕宽的一半 display.cy屏幕高的一半 display.cl屏幕安全区宽的一半的负值 display.cr屏幕安全区宽的一半 display.ct 屏幕安全区高的一半的 display.cb屏幕安全区高的一半负值 display.left安全区域的x值 display.rightdisplay.left + display.width display.topdisplay.bottom + display.height display.bottom安全区域的y值 display.center中心 cc.p(display.cx ,display.cy) var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Solitaire项目笔记/项目概况/2.UI绘制/":{"url":"Solitaire项目笔记/项目概况/2.UI绘制/","title":"2.UI绘制","keywords":"","body":"Introduction Solitaitr项目笔记 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Solitaire项目笔记/项目概况/3.热更新/1.常见问题.html":{"url":"Solitaire项目笔记/项目概况/3.热更新/1.常见问题.html","title":"1.常见问题","keywords":"","body":"常见问题 1.本地测试时，如何不拉取最新的代码。 删除sub-project/download/src文件夹下除project.manifest外的所有文件。 修改project.manifest中的version值，修改为一个很大值即可。 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Solitaire项目笔记/项目概况/3.热更新/2.线上项目更新流程.html":{"url":"Solitaire项目笔记/项目概况/3.热更新/2.线上项目更新流程.html","title":"2.线上项目更新流程","keywords":"","body":"线上项目更新流程 具体流程参考文档 点击这里 更新流程简单梳理 更新代码和资源的生成 检查三个项目solitaire_client、sub-project、solitaire-editor热更分支。 注意版本号 solitaire_client/sub-project/ver_config/config.json的Release.scriptVersion 版本号一般+5。 { \"Debug\": { \"packageUrl\": \"http://s3.elestorm.com:8089/solitaire/aaa_spider_script/\", \"remoteManifestUrl\": \"http://s3.elestorm.com:8089/solitaire/aaa_spider_script/\", \"remoteVersionUrl\": \"http://s3.elestorm.com:8089/solitaire/aaa_spider_script/version.manifest\", \"resourceUrl\": \"http://s3.elestorm.com:8089/solitaire/\", \"scriptVersion\": \"10615\" }, \"Release\": { \"packageUrl\": \"https://d3ojlo1yamgaff.cloudfront.net/aaa_spider_script/\", \"remoteManifestUrl\": \"https://d3ojlo1yamgaff.cloudfront.net/aaa_spider_script/\", \"remoteVersionUrl\": \"https://d3ojlo1yamgaff.cloudfront.net/aaa_spider_script/version.manifest\", \"resourceUrl\": \"https://d3ojlo1yamgaff.cloudfront.net/\", \"scriptVersion\": \"13045\" } } 使用脚本发布刚更新的脚本. 定位到目录solitaire_client/sub-project/tools/使用脚本 python publish_js.py 会出现两次确认第一次输入 0，第二次查看信息是否正确,正确按y会在solitaire_client/publish/script目录下生成热更的脚本文件。 资源的热更文件生成参考文档 更新脚本和资源的上传。 以文档为准，查看流程图自己校对每个步骤 脚本流程分为 start=>start: 开始 selectPro=>operation: 选择项目 totemp=>operation: 点开临时文件夹aaatemp 删除旧版本，上传新版本，会自动解压，解压成功后飞书自动通知 move=>operation: 将该文件夹移动至aaa_spider_script uploadVer=>operation: 上传版本信息并覆盖 invalid=>operation: 做失效处理,具操作参照文档 start->selectPro->totemp->move->uploadVer->invalid 更新注意事项 1.修改线上版本bug 首先要切换到线上版本的最新分支，一般是release_版本号的形式。再此分支修改。修改完成后，测试，然后走热更流程。完成后，提交一次修改，保留记录。 2.大版本更新。 使用master分支,走热更流程，热更完成后，分出release_版本号的形式的分支备份，用于线上版本的bug修改和还原。 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Solitaire项目笔记/项目概况/3.热更新/":{"url":"Solitaire项目笔记/项目概况/3.热更新/","title":"3.热更新","keywords":"","body":"Introduction Solitaitr项目笔记 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Solitaire项目笔记/项目概况/4.骰子活动/1.骰子活动扩展.html":{"url":"Solitaire项目笔记/项目概况/4.骰子活动/1.骰子活动扩展.html","title":"1.骰子活动扩展","keywords":"","body":"骰子活动扩展(换皮) 特别注意 因为是在老代码的上进行的修改，耦合较高，动作过分依赖某些节点。此活动扩展性不是很高扩展时，新增代码，不要动旧代码。防止原来的活动出现问题，通过skin值来决定使用旧代码还是新代码 注意事项： 资源名称尽量保持一致。包括图片，spine动画，音效等避免不必要修改。 某一个类修改过大时，不要在原来代码上修改，避免影以前代码，需要新建子类进行扩展。 所有节点的数量和名称尽量保持一致，尽量不要删除节点。 1.入口按钮 文件: HomePlayLayer.js 方法: initShellActivity 说明: 入口按钮的绘制 代码位置:DiceShellActivityBtn.js 修改方法:根据皮肤新增相关绘制方法即可，仿照createSummerBtn即可 2.游戏场景卡牌上的收集物 收集物数量的计算 文件: GameController.js 方法: initDiceShell 说明: 管理牌上是否出现活动道具 计算本关可以出现几个道具。 收集物的显示 文件: CardEntity.js 方法: initActiveSkillDiceShell 说明: 在牌上显示收集物 配置文件: DiceShellCardConfig.js 游戏界面收集图标显示 文件: HeadBar.js 方法: initDiceShell 配置文件: DiceShellPlayLayerConfig.js 3.结算界面 结算界面道具收集 文件: ResultNode.js 位置: if (this._gameData[\"shell_num\"] !== undefined && shell_node) { 配置文件: DiceShellResultNode.js 修改方法:根据皮肤新增相关绘制方法即可，仿照createSummerResultNode即可。 4.活动游戏界面。 弹窗界面 奖励展示界面 DiceReceiveRewardLayer.js 骰子购买界面 DiceShellBuyDiceLayer.js 活动结束界面 DiceShellEndLayer.js 引导界面 DiceExplainLayer.js 以上界面替换cocoscreator导出资源即可。 动作类 查看文件夹activity/diceShell/animation的类 UI类 查看文件夹activity/diceShell/ui的类 看代码，解决一切疑惑，不懂你找我 5.数据管理类 DiceShellDataMgr.js var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Solitaire项目笔记/项目概况/4.骰子活动/2.骰子活动说明.html":{"url":"Solitaire项目笔记/项目概况/4.骰子活动/2.骰子活动说明.html","title":"2.骰子活动说明","keywords":"","body":"骰子活动说明 策划文档 这里 所在目录 activity/diceShell 目录结构 关于类的具体功能看类的具体注释 diceShell ├── Dice3DPlay.js 3d骰子 ├── DiceEnum.js 枚举 ├── DiceExplainLayer.js 帮助界面 ├── DiceReceiveRewardLayer.js 奖励展示界面 ├── DiceShellActivityBtn.js 入口按钮绘制 ├── DiceShellBuyDiceLayer.js 骰子购买界面 ├── DiceShellDataMgr.js 骰子活动界面管理 ├── DiceShellEndLayer.js 骰子活动结束提示界面 ├── DiceShellMainLayer.js 骰子活动游戏界面 ├── DiceShellResultNode.js 骰子活动在结算界面的节点 ├── _init.js ├── animation │ ├── DiceRewardAni.js 道具奖励动作 │ ├── DiceShellAniMgr.js 动作管理 │ ├── DiceShellCheeseAni.js 棋盘动作 │ └── _init.js └── ui ├── DiceShellUIMgr.js UI界面管理类 ├── DiceShellUIUtil.js UI创建工具类 ├── _init.js ├── config │ ├── DiceShellBgConfig.js 背景界面配置 │ ├── DiceShellBtnConfig.js 骰子按钮配置 │ ├── DiceShellCardConfig.js 纸牌收集物显示配置 │ ├── DiceShellCheeseMapConfig.js 棋盘配置 │ ├── DiceShellPlayLayerConfig.js 扑克牌游戏界面配置 │ ├── DiceShellbarConfig.js 收集物进度条配置 │ └── _init.js └── skin_summer ├── DiceShellBgNode.js 背景UI ├── DiceShellCheeseMap.js 棋盘UI ├── DiceShellDiceBtn.js 骰子按钮UI ├── DiceShellProBarNode.js 收集物(贝壳)进度UI ├── DiceShellTitleNode.js titleUI └── _init.js 目前主要修改 animation 和 ui 文件夹中的文件是为了给DiceShellMainLayer.js瘦身，减少不必要代码的阅读量而创建的。是为了减少DiceShellMainLayer.js代码量，便于阅读和修改。 animation 中的文件目前与DiceShellMainLayer.js耦合度很高，修改时尽量注意。注意方法中this的指代，尽量使用apply或者call的形式调用。 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Solitaire项目笔记/项目概况/4.骰子活动/":{"url":"Solitaire项目笔记/项目概况/4.骰子活动/","title":"4.骰子活动","keywords":"","body":"Introduction 骰子活动 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Solitaire项目笔记/项目概况/5.版本更新/1.版本更新注意事项.html":{"url":"Solitaire项目笔记/项目概况/5.版本更新/1.版本更新注意事项.html","title":"1.版本更新注意事项","keywords":"","body":"版本更新注意事项 打包版本更新 重要 和策划确认GM工具的上的配置。 确认solitaire-editor的配置。 脚本和资源版本号 注意脚本和资源版本号的一致。 脚本新功能一定要区分版本，防止脚本更新后老版本调用新的接口。 关卡总数更新 关卡总数更新后，需要关注一下以下功能的修改。 拼图功能 bgDownLoadAction: function (fileList){ let clientVer = CheckVersionHelper.getInstance().getLocalClientVersion(); if(clientVer>12000){ // 关注一下这里需要手动修改 for(let i=3;i 联赛功能已在登录是进行了修改 EliteDataMgr.getInstance().loginIn(response.elite_tour); var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Solitaire项目笔记/项目概况/5.版本更新/":{"url":"Solitaire项目笔记/项目概况/5.版本更新/","title":"5.版本更新","keywords":"","body":"Introduction var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"TypeScript学习/1.基础类型.html":{"url":"TypeScript学习/1.基础类型.html","title":"1.基础类型","keywords":"","body":" 基础类型 number 布尔型 boolean 字符串 数组 元组 Tuple 枚举 any void null undefined Never Object 类型断言 基础类型 number 所有数字都是浮点数 支持二进制 0b 八进制 0o 十进制100 十六进制 0x 布尔型 boolean 布尔值 字符串 使用''或者 \"\"表示字符串 也可以使用模板字符串 `` 使用 ${}嵌入表达式 let bob = { name: 'bob', age: 10 } let bobInfo = `pperson name is ${bob.name}, age is ${bob.age + 1}; ` console.log(bobInfo); /* pperson name is bob, age is 11; */ 数组 两种表示方法 直接在元素类型的后面加上 []let array1: number[] = [1, 2, 3, 4]; console.log(array1);//[ 1, 2, 3, 4 ] 数组泛型let array2: Array = ['hello', 'world', '!']; console.log(array2);//[ 'hello', 'world', '!' ] 元组 Tuple 表示一个已知元素数量和类型的数组 各类型不必相同 let tuple: [string, number]; tuple = ['key1', 1]; console.log(tuple[0]);//key1 元组越界后会使用联合类型 tuple.push(100);//可以 100 是 number 类型 console.log(tuple.length); // tuple.push(false); //类型“boolean”的参数不能赋给类型“string | number”的参数 枚举 enum Color { Red, Black }; 后面详细讲解 any 与 Object的区别 Object类型的变量允许赋任意值 但是只能调用Object上的的方法any 没有这个限制 let any1: any = 10; console.log(any1.toFixed()); let object1: Object = 10; // console.log(object1.toFixed());//类型“Object”上不存在属性“toFixed” void 只能被赋予 null undefined 函数无返回值是可以使用 void null undefined TypeScript里，undefined和null两者各自有自己的类型分别叫做undefined和null 当你指定了strictNullChecks标记，null和undefined只能赋值给void和它们各自 默认这个标记是关闭的 Never 永远不存在的类型 任何值都不能赋值给never 总是会抛出异常或者根本不会有返回值的函数 可以返回Never // 返回never的函数必须存在无法达到的终点 function error(message: string): never { throw new Error(message); } // 推断的返回值类型为never function fail() { return error(\"Something failed\"); } // 返回never的函数必须存在无法达到的终点 function infiniteLoop(): never { while (true) { } } Object 非原始类型 类型断言 类型断言 as 或者 <> 使用jsx时 只能使用as语句 使用类型断言可以逃避编译器的数据检查和解构 没有运行时的影响 只是会影响编译阶段 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"TypeScript学习/2.变量声明.html":{"url":"TypeScript学习/2.变量声明.html","title":"2.变量声明","keywords":"","body":" 变量声明 var 和 let var let 作用域的问题 解构 数组解构 对象解构 ...展开 1.将一个数组展开为另一个数组 2.展开对象 变量声明 var 和 let ES6中有过详细介绍，基本用法一致 var 经常出现的一些问题 var存在变量提升 与js一样不在多次赘述 var不论声明多少次 你只会得到一个 ```ts function test(): number { var sum = 0; for (var i = 0; i console.log(\"outSide i \", i); //重复声明不会报错,从而导致循环并不是按照你的预期进行, for (var i = 0; i } return sum; } test(); / outSide i 0 inside i 0 inside i 1 inside i 2 inside i 3 inside i 4 inside i 5 inside i 6 inside i 7 inside i 8 inside i 9 inside i 10 / #### let * let 声明的变量在使用前 会发生错误 ，这就是TDZ(Temporal Dead Zone)暂时性死区 ```ts console.log(a);//声明之前已使用的块范围变量“a”。 let a: number = 10; 特例有一种情况不会 当 let 声明的变量在一个函数中被调用 只要在声明前没有调用过该函数 不会报错产生死区。 function test2() { return a; } let a: number = 10; console.log(test2()); 作用域的问题 var 只受全局作用域和函数作用域的影响。let 同时还要受到块级作用域约束 let data1 = 10; var data2 = 20; if (data1 === 10 && data2 === 20) { let data1 = 100; var data2 = 100; } console.log(data1, data2);//10,100 解构 参考地址 数组解构 // 数组解构 let [num1, num2] = [1, 2, 3, 4];//1,2 let [, number2, , number4] = [5, 6, 7, 8];//6,8 // ...rest let [number1, ...rest] = [1, 2, 3, 4, 5];//1,[2,3,4,5] 对象解构 普通模式let objTest = { oa: 10, ob: 20, oc: \"datastring\", od: \"odstr\" } let { oa, ob, oc } = objTest; console.log(oa, ob, oc);//10,20 datastring let { od, ...restO } = objTest; console.log(od, restO);//datastring { oa: 10, ob: 20 } 属性重命名 let { oa: obj1, ob: obj2 }: { oa: number, ob: number } = objTest; console.log(obj1, obj2);//10 20 默认值 ```ts let { oe = 1000 }: { oe?: number, [indexs: string]: any } = { oa: \"stringa\" }; console.log(oe);//1000 function keepWholeObject({ oe = 1000 }: { [indexs: string]: any }) { console.log(oe); } keepWholeObject({ a: 100, oe: 2000 });//2000 * 类型推断 ```ts function f({ a = 10, b = \"a\" } = {}) { }//类型推断 推断为{a?:number,b?:string} f({ b: \"100\" }); function f2({ a, b = 0 } = { a: \"\" }): void { // ... }//推断类型 { a: string; b?: number; } f2({ a: \"ok\" }) ...展开 1.将一个数组展开为另一个数组 let first = [1, 2]; let second = [3, 4]; let aaa; let third = [0, ...first, ...second, 5, 6]; console.log('third:', third); 2.展开对象 仅仅包含对象的自身的可枚举类型 class testC { name = 14; funcTest() { } } let testc = new testC(); console.log({ ...testc });//{ name: 14 } 同名属性会被覆盖 let defaults = { a: 10, b: 100, name: 'bob', func: function () { } }; let testObj = { a: 100, ...defaults }; console.log('testObj:', testObj);//testObj: { a: 10, b: 100, name: 'bob', func: [Function: func] } var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"TypeScript学习/3.接口.html":{"url":"TypeScript学习/3.接口.html","title":"3.接口","keywords":"","body":" 接口 简单接口 接口可选属性 对象字面化 额外属性检查的好处 解决对象字面话 额外属性检查的方案 索引类型 函数 类 接口继承 混合类型 接口 TypeScript的核心原则之一是对值所具有的结构进行类型检查。 它有时被称做“鸭式辨型法”或“结构性子类型化”。 在TypeScript里，接口的作用就是为这些类型命名和为你的代码或第三方代码定义契约。 简单接口 interface LabelledValue { label: string; } 接口可选属性 使用?来表示 interface SquareConfig { color?: string, width?: number } function createSquare(config: SquareConfig): { color: string; area: number } { return { color: \"\", area: 100 }; } let data2 = { colour: \"red\", width: 100 }; let mySquare = createSquare(data2); 对象字面化 对象字面话会被特殊对待 产生额外的属性检查 //对象文字只能指定已知的属性，但“colour”中不存在类型“SquareConfig” let mySquare2 = createSquare({ colour: \"red\", width: 100 }); 额外属性检查的好处 检查属性的拼写错误 对存在的属性进行预定义 解决对象字面话 额外属性检查的方案 as 使用类型推论 逃避 编译阶段 接口使用索引类型 添加字符串索引签名 [propName: string]: any; 将对象赋值给一个变量 使用变量作为参数 也可以避开额外的检查 索引类型 数字索引 ```ts interface IStringArray { [index: number]: string; } let stringArray: IStringArray = [\"bob\", \"test\"]; console.log(stringArray[0]); * 字符串索引 ```ts interface IStringArrayTwo { [index: string]: string; } 注意两种索引可以同时使用 ，但是数字索引的返回类型必须是字符串索引的返回类型的子类 class Animal { name: string; } class Dog extends Animal { breed: string; } //Error 数字索引类型“Animal”不能赋给字符串索引类型“Dog”。 interface NotOkay { [x: number]: Animal; [x: string]: Dog; } 函数 interface ISearchFunc { (source: string, substring: string): boolean; } let serachFunc1: ISearchFunc; //参数名称没有必要一致 serachFunc1 = function (sourcea: string, subString: string): boolean { let result = sourcea.search(subString); console.log('result', result); return result > -1; } console.log(serachFunc1(\"hello 'world'\", \"world\")); 类 接口描述了类的公共部分,它不会帮类检查私有部分类 实例部分 和 静态部分一个类实现一个接口时 只会对其实例部分进行检查constructor 存在于类的静态部分 interface ClockConstructor { new(hour: number, minute: number); } class Clock implements ClockConstructor { currentTime: Date; constructor(h: number, m: number) { } } 我们应该直接操作类的静态部分 interface ClockConstructor { new(hour: number, minute: number): ClockInterface; } interface ClockInterface { getTime(): void; } function createClock(ctor: ClockConstructor, hour: number, minute: number): ClockInterface { return new ctor(hour, minute); } class ClockA implements ClockInterface { constructor(hour: number, minute: number) { } getTime(): void { } } class ClockB { constructor(hour: number, minute: number) { } getTime(): void { } } createClock(ClockA, 10, 10); createClock(ClockB, 10, 10); 接口继承 接口可以继承接口 interface Shape { color: string; } interface PenStroke { penWidth: number; } interface Square extends Shape, PenStroke { sideLength: number; } 接口也可以继承类当你创建了一个接口继承了一个拥有私有或受保护的成员的类时，这个接口类型只能被这个类或其子类所实现（implement）。 ```ts class Control { protected mState: number; constructor(state: number) { this.mState = state; } } interface ISelectAble extends Control { showState(): void; } class ControlA extends Control implements ISelectAble { constructor(state: number) { super(state); } showState() { console.log(\"mState\", this.mState); } } class ControlB extends Control implements ISelectAble { constructor(state: number) { super(state); } showState() { console.log(\"mState\", this.mState); } } ### 混合类型 有时你会希望一个对象可以同时具有上面提到的多种类型。 ```ts interface Counter { (start: number): string; interval: number; reset(): void; } function getCounter(): Counter { let counter = function (start: number) { }; counter.interval = 123; counter.reset = function () { }; return counter; } let c = getCounter(); c(10); c.reset(); c.interval = 5.0; var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"TypeScript学习/4.类.html":{"url":"TypeScript学习/4.类.html","title":"4.类","keywords":"","body":" 类 继承 extends 关键字 不在赘述 super() 修饰符 存取器 set get 直接看例子 抽象类 abstract 与C++类似 不在介绍 小技巧 参数属性 类 继承 extends 关键字 不在赘述 super() 派生类 调用 父类方法 修饰符 private私有属性 只能在本类中访问 protected 受保护的属性 只能在本类和派生类中使用 public公共属性 都可以访问 readonly只读属性 只能在声明或者构造函数中赋值 static静态属性 存取器 set get 直接看例子 let passcode = \"secret passcode\"; class Employee { private _fullName: string; get fullName(): string { return this._fullName; } set fullName(newName: string) { if (passcode && passcode == \"secret passcode\") { this._fullName = newName; } else { console.log(\"Error: Unauthorized update of employee!\"); } } } let employee = new Employee(); employee.fullName = \"Bob Smith\"; if (employee.fullName) { alert(employee.fullName); }} 抽象类 abstract 与C++类似 不在介绍 例子 abstract class Department { constructor(public name: string) { } printName(): void { console.log('Department name: ' + this.name); } abstract printMeeting(): void; // 必须在派生类中实现 } class AccountingDepartment extends Department { constructor() { super('Accounting and Auditing'); // 在派生类的构造函数中必须调用 super() } printMeeting(): void { console.log('The Accounting Department meets each Monday at 10am.'); } generateReports(): void { console.log('Generating accounting reports...'); } } let department: Department; // 允许创建一个对抽象类型的引用 department = new Department(); // 错误: 不能创建一个抽象类的实例 department = new AccountingDepartment(); // 允许对一个抽象子类进行实例化和赋值 department.printName(); department.printMeeting(); department.generateReports(); // 错误: 方法在声明的抽象类中不存在 小技巧 参数属性 仅在构造函数里使用 readonly name: string参数来创建和初始化 name成员。 我们把声明和赋值合并至一处。 class Octopus { readonly numberOfLegs: number = 8; constructor(readonly name: string) { } } var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"TypeScript学习/5.函数.html":{"url":"TypeScript学习/5.函数.html","title":"5.函数","keywords":"","body":" 函数 完整的写法 推断函数返回值 参数 函数中的this 函数的重载 函数 完整的写法 let myAdd: (x: number, y: number) => number = function(x: number, y: number): number { return x + y; }; 推断函数返回值 函数可以不写返回值 TS可以自己推断出返回值 参数 普通参数 可选参数参数后面添加?可选参数必须在必须参数的后面 function buildName(firstName: string, lastName?: string) { if (lastName) return firstName + \" \" + lastName; else return firstName; } let result1 = buildName(\"Bob\"); // works correctly now let result2 = buildName(\"Bob\", \"Adams\", \"Sr.\"); // error, too many parameters let result3 = buildName(\"Bob\", \"Adams\"); // ah, just right 默认参数 不需要卸载后面 当参数为undefined是会启用默认参数 function buildName(firstName: string, lastName = \"Smith\") { return firstName + \" \" + lastName; } let result1 = buildName(\"Bob\"); // works correctly now, returns \"Bob Smith\" let result2 = buildName(\"Bob\", undefined); // still works, also returns \"Bob Smith\" let result3 = buildName(\"Bob\", \"Adams\", \"Sr.\"); // error, too many parameters let result4 = buildName(\"Bob\", \"Adams\"); 剩余参数 ...args:any [] function buildName(firstName: string, ...restOfName: string[]) { return firstName + \" \" + restOfName.join(\" \"); } let employeeName = buildName(\"Joseph\", \"Samuel\", \"Lucas\", \"MacKinzie\"); 函数中的this 参考此文章 函数的重载 let suits = [\"hearts\", \"spades\", \"clubs\", \"diamonds\"]; function pickCard(x: {suit: string; card: number; }[]): number; function pickCard(x: number): {suit: string; card: number; }; function pickCard(x): any { // Check to see if we're working with an object/array // if so, they gave us the deck and we'll pick the card if (typeof x == \"object\") { let pickedCard = Math.floor(Math.random() * x.length); return pickedCard; } // Otherwise just let them pick the card else if (typeof x == \"number\") { let pickedSuit = Math.floor(x / 13); return { suit: suits[pickedSuit], card: x % 13 }; } } let myDeck = [{ suit: \"diamonds\", card: 2 }, { suit: \"spades\", card: 10 }, { suit: \"hearts\", card: 4 }]; let pickedCard1 = myDeck[pickCard(myDeck)]; alert(\"card: \" + pickedCard1.card + \" of \" + pickedCard1.suit); let pickedCard2 = pickCard(15); alert(\"card: \" + pickedCard2.card + \" of \" + pickedCard2.suit); var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"TypeScript学习/6.枚举.html":{"url":"TypeScript学习/6.枚举.html","title":"6.枚举","keywords":"","body":" 枚举 数字枚举 反向映射 字符串枚举 异类枚举 计算的常量成员 联合枚举和枚举成员类型 const 枚举 枚举 数字枚举 enum Director { Left = 1, Righr, Up, Down } 转换为js var Director; (function (Director) { Director[Director[\"Left\"] = 1] = \"Left\"; Director[Director[\"Righr\"] = 2] = \"Righr\"; Director[Director[\"Up\"] = 3] = \"Up\"; Director[Director[\"Down\"] = 4] = \"Down\"; })(Director || (Director = {}))} 这样就产生了反向映射 反向映射 只有数字枚举会生成反向映射 console.log(Director.Left);//1 console.log(Director[1]);//Left 字符串枚举 enum DirString{ Up = 'Up', Down = 'Down', Left = 'Left', Right ='Up', } 转为js var DirString; (function (DirString) { DirString[\"Up\"] = \"Up\"; DirString[\"Down\"] = \"Down\"; DirString[\"Left\"] = \"Left\"; DirString[\"Right\"] = \"Up\"; })(DirString || (DirString = {})); 不会产生反向映射 异类枚举 enum BooleanLikeHeterogeneousEnum { No = 0, Yes = \"YES\", } 没有特殊的用法最好不要这么写 计算的常量成员 常量枚举表达式 enum FileAccess { // constant members None, Read = 1 联合枚举和枚举成员类型 字面量枚举成员 字符串字面量(\"a\") 数字字面量(0,100) 负数(-1,-2) 这样的枚举成员就成了类型 enum ShapeKind { Circle, Square, } interface Circle { kind: ShapeKind.Circle; radius: number; } interface Square { kind: ShapeKind.Square; sideLength: number; } 同样枚举就变成了每个枚举成员的联合 ShapeKind 的类型就是 ShapeKind.Circle | ShapeKind.Square const 枚举 常量枚举只能使用常量枚举表达式，并且不同于常规的枚举，它们在编译阶段会被删除 不会出现在编译完成的js文件中 const enum Directions { Up, Down, Left, Right } let directions = [Directions.Up, Directions.Down, Directions.Left, Directions.Right] 编译后的js内容 var directions = [0 /* Up */, 1 /* Down */, 2 /* Left */, 3 /* Right */]; var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"TypeScript学习/7.泛型.html":{"url":"TypeScript学习/7.泛型.html","title":"7.泛型","keywords":"","body":" 泛型 写法 基本使用 泛型类 泛型约束 泛型 写法 function Identify(args:T):T{ return args; } //完整写法 console.log(Identify('helllo')); //ts会进行推断 可以简写 console.log(Identify(10)); console.log(Identify('hello world')); console.log(Identify({a:100})); 基本使用 与普通类型差别不大 可以这样使用 泛型变量let generic1:(args:U)=>U = Identify; 使用带有签名的对象字面量let generic2:{(args:U):U} = Identify 泛型接口interface IGeneric{ (args:T):T } let generic3:IGeneric = Identify 泛型类 class GenericNumber { zeroValue: T; add: (x: T, y: T) => T; } let myGenericNumber = new GenericNumber(); myGenericNumber.zeroValue = 0; myGenericNumber.add = function(x, y) { return x + y; }; 泛型约束 使用接口约束 class GenericNumber { zeroValue: T; add: (x: T, y: T) => T; } let myGenericNumber = new GenericNumber(); myGenericNumber.zeroValue = 0; myGenericNumber.add = function(x, y) { return x + y; }; 使用类型约束 function getProperty(obj: T, key: K) { return obj[key]; } let x = { a: 1, b: 2, c: 3, d: 4 }; getProperty(x, \"a\"); // okay 使用类类型 function create(c: {new(): T; }): T { return new c(); } var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"TypeScript学习/8.类型推断和类型兼容.html":{"url":"TypeScript学习/8.类型推断和类型兼容.html","title":"8.类型推断和类型兼容","keywords":"","body":"类型推断 ts对未设置类型变量会进行类型推断 类型兼容性 基本原则 X要兼容Y, Y至少要有X的相同属性 函数兼容 函数返回值兼容性 函数返回值的兼容 使用类型兼容基本原则 函数参数的兼容性函数X的每个参数都能在函数Y中找到位置并且类型相同的参数 名字无所谓 枚举兼容 数字类型 和 枚举类型 兼容 enum Director { Left = 1, Righr, Up, Down } let state :Director = 10; 不同枚举间不兼容 类的兼容性 属性没有修饰符修饰时 和对象差不多 ```ts class Animal { feet: number; constructor(name: string, numFeet: number) { } } class Size { feet: number; constructor(numFeet: number) { } } let a: Animal; let s: Size; a = s; // OK s = a; // OK * 私有成员和受保护的成员 类的私有变量和受保护变量 必须时同一声明 详情参看 private 和 protected 也就是说父类 兼容 子类 ### 泛型的兼容 * 没有指定泛型类型的泛型参数时，统一按照any处理,指定参数时便不会兼容 ```ts interface Empty { } let x: Empty; let y: Empty; x = y; // OK, because y matches structure of x interface NotEmpty { data: T; } let x: NotEmpty; let y: NotEmpty; x = y; // Error, because x and y are not compatible var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"TypeScript学习/9.高级类型.html":{"url":"TypeScript学习/9.高级类型.html","title":"9.高级类型","keywords":"","body":" 高级类型 交叉类型 联合类型 类型保护与区分类型 类型别名 type 字符串字面量类型 可辨识联合 索引类型 映射类型 高级类型 交叉类型 多种类型可以叠加成一种类型 关键字 & TS源码 interface ObjectConstructor { assign(target: T, source: U): T & U; } interface A { name: string, age: number, sayName: (name: string) => void } interface B { name: string, gender: string, sayGender: (gender: string) => void } let a: A & B // 都是合法的 a.age a.sayName 联合类型 联合类型表示一个值可以是几种类型之一。 我们用竖线（ |）分隔每个类型，所以 number | string | boolean表示一个值可以是 number， string，或 boolean。 类型保护与区分类型 typeof 这些typeof类型保护只有两种形式能被识别： typeof v === \"typename\"和 typeof v !== \"typename\"。\"typename\"必须是 \"number\"， \"string\"， \"boolean\"或 \"symbol\"。function padLeft(value: string, padding: string | number) { if (typeof padding === \"number\") { return Array(padding + 1).join(\" \") + value; } if (typeof padding === \"string\") { return padding + value; } throw new Error(`Expected string or number, got '${padding}'.`); } instanceof instanceof类型保护是通过构造函数来细化类型的一种方式 instanceof的右侧要求是一个构造函数 ```ts interface Padder { getPaddingString(): string } class SpaceRepeatingPadder implements Padder { constructor(private numSpaces: number) { } getPaddingString() { return Array(this.numSpaces + 1).join(\" \"); } } class StringPadder implements Padder { constructor(private value: string) { } getPaddingString() { return this.value; } } function getRandomPadder() { return Math.random() // 类型为SpaceRepeatingPadder | StringPadder let padder: Padder = getRandomPadder(); if (padder instanceof SpaceRepeatingPadder) { padder; // 类型细化为'SpaceRepeatingPadder' } if (padder instanceof StringPadder) { padder; // 类型细化为'StringPadder' } * is ```ts interface Bird { fly(); layEggs(); } interface Fish { swim(); layEggs(); } function getSmallPet(): Fish | Bird { // ... } function isFish(pet: Fish | Bird): pet is Fish { return (pet).swim !== undefined; } // 'swim' 和 'fly' 调用都没有问题了 let pet = getSmallPet(); if (isFish(pet)) { pet.swim(); } else { pet.fly(); } 类型别名 type 字面意思 给类型起一个别的名字 type Name = string; type NameResolver = () => string; type NameOrResolver = Name | NameResolver; function getName(n: NameOrResolver): Name { if (typeof n === 'string') { return n; } else { return n(); } } 类型别名也可以是泛型 type Container = { value: T }; 和接口的区别 类型别名不会创建一个新的名字 接口会创建一个新的名字 类型别名不能 extends 和 implements 字符串字面量类型 字符串字面量类型允许你指定字符串必须的固定值。 在实际应用中，字符串字面量类型可以与联合类型，类型保护和类型别名很好的配合 type Easing = \"ease-in\" | \"ease-out\" | \"ease-in-out\"; class UIElement { animate(dx: number, dy: number, easing: Easing) { if (easing === \"ease-in\") { // ... } else if (easing === \"ease-out\") { } else if (easing === \"ease-in-out\") { } else { // error! should not pass null or undefined. } } } let button = new UIElement(); button.animate(0, 0, \"ease-in\"); button.animate(0, 0, \"uneasy\"); // error: \"uneasy\" is not allowed here 你只能从三种允许的字符中选择其一来做为参数传递，传入其它值则会产生错误。 字符串字面量类型还可以用于区分函数重载 function createElement(tagName: \"img\"): HTMLImageElement; function createElement(tagName: \"input\"): HTMLInputElement; // ... more overloads ... function createElement(tagName: string): Element { // ... code goes here ... } 可辨识联合 interface Square { kind: \"square\"; size: number; } interface Rectangle { kind: \"rectangle\"; width: number; height: number; } interface Circle { kind: \"circle\"; radius: number; } //首先我们声明了将要联合的接口。 // 每个接口都有 kind属性但有不同的字符串字面量类型。 // kind属性称做 可辨识的特征或 标签。 type Shape = Square | Rectangle | Circle; function area(s: Shape) { switch (s.kind) { case \"square\": return s.size * s.size; case \"rectangle\": return s.height * s.width; case \"circle\": return Math.PI * s.radius ** 2; } } 完整性检查 当没有涵盖所有可辨识联合的变化时，我们想让编译器可以通知我们。 比如，如果我们添加了 Triangle到 Shape，我们同时还需要更新 area: 使用never完成提示 function assertNever(x: never): never { throw new Error(\"Unexpected object: \" + x); } function area(s: Shape) { switch (s.kind) { case \"square\": return s.size * s.size; case \"rectangle\": return s.height * s.width; case \"circle\": return Math.PI * s.radius ** 2; default: return assertNever(s); // error here if there are missing cases } } 索引类型 function pluck(o: T, names: K[]): T[K][] { return names.map(n => o[n]); } interface Person { name: string; age: number; } let person: Person = { name: 'Jarid', age: 35 }; let strings: string[] = pluck(person, ['name']); // ok, string[] 索引类型和字符串索引签名 interface Map { [key: string]: T; } let keys: keyof Map; // string let value: Map['foo']; // number 映射类型 同态映射类型 只操作类型的属性映射为另一个类型 不会新增属性 Readonly Partial Pick 等 非同态映射类型 会引入新属性 * var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"TypeScript学习/10.装饰器.html":{"url":"TypeScript学习/10.装饰器.html","title":"10.装饰器","keywords":"","body":" 装饰器 装饰器的写法 装饰器执行顺序 各种装饰器 装饰器 装饰器的写法 普通装饰器function sealed(target) { // do something with \"target\" ... } 装饰器工厂 function color(value: string) { // 这是一个装饰器工厂 return function (target) { // 这是装饰器 // do something with \"target\" and \"value\"... } } 装饰器组合 // 书写在多行 @f @g x // 书写在同一行 @f @g x 装饰器执行顺序 由上至下依次对装饰器表达式求值。 求值的结果会被当作函数，由下至上依次调用。 类中不同声明上的装饰器将按以下规定的顺序应用： 参数装饰器，然后依次是方法装饰器，访问符装饰器，或属性装饰器应用到每个实例成员。 参数装饰器，然后依次是方法装饰器，访问符装饰器，或属性装饰器应用到每个静态成员。 参数装饰器应用到构造函数。 类装饰器应用到类。 各种装饰器 // 装饰器 // 类修饰器 重构构造 function classDecorator(constructor:T) { console.log('target:any,paramName:any,index:any',constructor); return class extends constructor { newProperty = \"new property\"; hello = \"override\"; // greeting = \"world\"; } } // 方法修饰器 function enumerable(value: boolean) { return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) { console.log(descriptor); descriptor.enumerable = value; }; } // 访问修饰器 function configurable(value: boolean) { return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) { descriptor.configurable = value; }; } // 属性装饰器 function format(params:string){ // 原型对象或者构造函数 和 属性名称 return function(target:any,attr:string){ console.log('format',attr); target[attr] = params; } } // 参数修饰器 function params(){ return function(target:any,paramName:any,index:any){ console.log('params',paramName); console.log('param',index); } } @classDecorator class Greeter { private property = \"property\"; hello: string; @format('100') greeting: string; @format(\"as\") static staticgreet:number; private _x: number; constructor(m: string) { this.hello = m; } @enumerable(false) greet() { return \"Hello, \" + this.greeting; } @configurable(false) get x(){ return this._x; } greets(@params() a:string){ console.log(a); } } let gretter = new Greeter('world'); console.log(Greeter.staticgreet); console.log(gretter.greet()); for (let key in gretter){ console.log(key,typeof gretter[key]); } var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"TypeScript学习/":{"url":"TypeScript学习/","title":"TypeScript学习","keywords":"","body":"TypeSctipt学习 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"命令学习/1.xcode命令.html":{"url":"命令学习/1.xcode命令.html","title":"1.xcode命令","keywords":"","body":" Xcode命令 一.Command Line Tool安装 通过终端安装 xcode-select --install 安装成功后再次输入 xcode-select --install 出现以下提示说明安装成功 二.xcode--select常用命令 显示帮助 xcode-select --help 打印安装位置 xcode-select --print-path 显示版本号 xcode-select --version 命令重置 xcode-select --reset 设置默认版本 sudo xcode-select -switch Xcode.app 3.xcodebuild的一些常用命令 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"命令学习/":{"url":"命令学习/","title":"命令学习","keywords":"","body":" 常用命令行命令 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"GLOSSARY.html":{"url":"GLOSSARY.html","keywords":"","body":" Git 分散式版本控制软件 Markdown Aaron Swartz 跟John Gruber共同设计的排版语言 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"}}