<!-- TOC -->

- [装饰器](#装饰器)
    - [装饰器的写法](#装饰器的写法)
    - [装饰器执行顺序](#装饰器执行顺序)
    - [各种装饰器](#各种装饰器)

<!-- /TOC -->
## 装饰器

### 装饰器的写法

* 普通装饰器
```ts
function sealed(target) {
    // do something with "target" ...
}
```
* 装饰器工厂
```ts
function color(value: string) { // 这是一个装饰器工厂
    return function (target) { //  这是装饰器
        // do something with "target" and "value"...
    }
}
```

* 装饰器组合

```ts
// 书写在多行
@f
@g
x
// 书写在同一行
@f @g x
```

### 装饰器执行顺序

1. 由上至下依次对装饰器表达式求值。
2. 求值的结果会被当作函数，由下至上依次调用。
* 类中不同声明上的装饰器将按以下规定的顺序应用：

1. 参数装饰器，然后依次是方法装饰器，访问符装饰器，或属性装饰器应用到每个实例成员。
2. 参数装饰器，然后依次是方法装饰器，访问符装饰器，或属性装饰器应用到每个静态成员。
3. 参数装饰器应用到构造函数。
4. 类装饰器应用到类。


### 各种装饰器
```ts
// 装饰器
// 类修饰器 重构构造
function classDecorator<T extends {new (...args:any []):{}}>(constructor:T) {
    console.log('target:any,paramName:any,index:any',constructor);
    return class extends constructor {
        newProperty = "new property";
        hello = "override";
        // greeting = "world";
    }
}

// 方法修饰器
function enumerable(value: boolean) {
    return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {
        console.log(descriptor);
        descriptor.enumerable = value;
    };
}
// 访问修饰器
function configurable(value: boolean) {
    return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {
        descriptor.configurable = value;
    };
}
// 属性装饰器
function format(params:string){
    // 原型对象或者构造函数 和 属性名称
   return function(target:any,attr:string){
       console.log('format',attr);
        target[attr] = params;
    }
}
// 参数修饰器

function params(){
    return function(target:any,paramName:any,index:any){
        console.log('params',paramName);
        console.log('param',index);
    }

}

@classDecorator
class Greeter {
    private property = "property";
    hello: string;
    @format('100')
    greeting: string;
    @format("as")
    static staticgreet:number;
    private _x: number;
    constructor(m: string) {
        this.hello = m;
    }
    @enumerable(false)
    greet() {
        return "Hello, " + this.greeting;
    }
    @configurable(false)
    get x(){
        return this._x;
    }

    greets(@params() a:string){
        console.log(a);
    }
}
let gretter = new Greeter('world');
console.log(Greeter.staticgreet);
console.log(gretter.greet());
for (let key in gretter){
    console.log(key,typeof gretter[key]);
}
```
