<!-- TOC -->

- [接口](#接口)
    - [简单接口](#简单接口)
    - [接口可选属性](#接口可选属性)
        - [对象字面化](#对象字面化)
        - [额外属性检查的好处](#额外属性检查的好处)
        - [解决对象字面话 额外属性检查的方案](#解决对象字面话-额外属性检查的方案)
    - [索引类型](#索引类型)
    - [函数](#函数)
    - [类](#类)
    - [接口继承](#接口继承)
    - [混合类型](#混合类型)

<!-- /TOC -->
## 接口
TypeScript的核心原则之一是对值所具有的结构进行类型检查。 它有时被称做“鸭式辨型法”或“结构性子类型化”。 在TypeScript里，接口的作用就是为这些类型命名和为你的代码或第三方代码定义契约。
### 简单接口
```ts
interface LabelledValue {
    label: string;
}
```

### 接口可选属性
使用?来表示  
```ts
interface SquareConfig {
    color?: string,
    width?: number
}
function createSquare(config: SquareConfig): { color: string; area: number } {
    return { color: "", area: 100 };
}

let data2 = { colour: "red", width: 100 };
let mySquare = createSquare(data2);
```
#### 对象字面化
对象字面话会被特殊对待 产生额外的属性检查
```js
//对象文字只能指定已知的属性，但“colour”中不存在类型“SquareConfig”
let mySquare2 = createSquare({ colour: "red", width: 100 });
```
#### 额外属性检查的好处
* 检查属性的拼写错误
* 对存在的属性进行预定义

#### 解决对象字面话 额外属性检查的方案
* 1. as 使用类型推论 逃避 编译阶段
* 2. 接口使用[索引类型](#索引类型) 添加字符串索引签名 [propName: string]: any; 
* 3. 将对象赋值给一个变量 使用变量作为参数 也可以避开额外的检查

### 索引类型
* 数字索引
```ts
interface IStringArray {
    [index: number]: string;
}
let stringArray: IStringArray = ["bob", "test"];
console.log(stringArray[0]);
```
* 字符串索引
```ts
interface IStringArrayTwo {
    [index: string]: string;
}
```
**注意**  
两种索引可以同时使用 ，但是``数字索引的返回类型``必须是``字符串索引的返回类型``的子类
```ts
class Animal {
    name: string;
}
class Dog extends Animal {
    breed: string;
}

//Error 数字索引类型“Animal”不能赋给字符串索引类型“Dog”。
interface NotOkay {
    [x: number]: Animal;
    [x: string]: Dog;
}
```

### 函数
```ts
interface ISearchFunc {
    (source: string, substring: string): boolean;
}

let serachFunc1: ISearchFunc;
//参数名称没有必要一致
serachFunc1 = function (sourcea: string, subString: string): boolean {
    let result = sourcea.search(subString);
    console.log('result', result);
    return result > -1;
}
console.log(serachFunc1("hello 'world'", "world"));
```

### 类
接口描述了类的公共部分,它不会帮类检查私有部分  
类 ``实例部分`` 和 ``静态部分``  
一个类实现一个接口时 只会对其实例部分进行检查  
constructor 存在于类的静态部分
```ts
interface ClockConstructor {
    new(hour: number, minute: number);
}

class Clock implements ClockConstructor {
    currentTime: Date;
    constructor(h: number, m: number) { }
}
```
我们应该直接操作类的静态部分  
```ts
interface ClockConstructor {
    new(hour: number, minute: number): ClockInterface;
}
interface ClockInterface {
    getTime(): void;
}
function createClock(ctor: ClockConstructor, hour: number, minute: number): ClockInterface {
    return new ctor(hour, minute);
}

class ClockA implements ClockInterface {
    constructor(hour: number, minute: number) {

    }
    getTime(): void {

    }
}

class ClockB {
    constructor(hour: number, minute: number) {

    }
    getTime(): void {

    }
}

createClock(ClockA, 10, 10);
createClock(ClockB, 10, 10);
```

### 接口继承
* 接口可以继承接口

```ts
interface Shape {
    color: string;
}

interface PenStroke {
    penWidth: number;
}

interface Square extends Shape, PenStroke {
    sideLength: number;
}
```

* 接口也可以继承类  
当你创建了一个接口继承了一个拥有私有或受保护的成员的类时，这个接口类型只能被这个类或其子类所实现（implement）。 
```ts
class Control {
    protected mState: number;
    constructor(state: number) {
        this.mState = state;
    }
}

interface ISelectAble extends Control {
    showState(): void;
}

class ControlA extends Control implements ISelectAble {
    constructor(state: number) {
        super(state);
    }
    showState() {
        console.log("mState", this.mState);
    }
}

class ControlB extends Control implements ISelectAble {
    constructor(state: number) {
        super(state);
    }
    showState() {
        console.log("mState", this.mState);
    }
}
```

### 混合类型
有时你会希望一个对象可以同时具有上面提到的多种类型。

```ts
interface Counter {
    (start: number): string;
    interval: number;
    reset(): void;
}

function getCounter(): Counter {
    let counter = <Counter>function (start: number) { };
    counter.interval = 123;
    counter.reset = function () { };
    return counter;
}

let c = getCounter();
c(10);
c.reset();
c.interval = 5.0;
```






