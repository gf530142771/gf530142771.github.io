<!-- TOC -->

- [let命令](#let命令)
    - [基本用法](#基本用法)
    - [与var的对照](#与var的对照)
- [块级作用域](#块级作用域)
    - [块级作用域存在的意义](#块级作用域存在的意义)
    - [块级作用域写法](#块级作用域写法)
- [块级作用域和函数声明](#块级作用域和函数声明)
- [const命令](#const命令)
    - [基本用法](#基本用法-1)
    - [本质](#本质)
- [ES6 声明变量的六种方法](#es6-声明变量的六种方法)
- [顶层对象属性](#顶层对象属性)

<!-- /TOC -->
## let命令
### 基本用法  
用于声明变量
```javascript
let a = 10;
console.log(10);
/*
10
*/
```

### 与var的对照
* 不存在变量的提升
```js
console.log(temp);
var temp;
/*
undefined
*/
```

```js
console.log(temp);
let temp;
/*
报错
Cannot access 'temp' before initialization 
*/
```
* 不允许重复声明
```js
var a = 10;
var a = 100;
console.log(a);
/*
100
*/

let b = 10;
let b = 100;

/*
报错
Identifier 'b' has already been declared
*/
```

* 暂时性死区  
只要块级作用域内存在**let**命令 那么它所声明的变量绑定这个区域 不受外部的的影响
```js
var temp = 10;
if(true){
    temp = 100
    let temp;
}
/*
报错
annot access 'temp' before initialization
*/
```
上面代码报错  
只要块作用域中 存在let命令 那么变量在没有被let声明之前都是不可用的  
这在语法上就叫做 <font color="#dd0000" size = 6 face="微软雅黑">暂时性死区</font>

## 块级作用域

### 块级作用域存在的意义
ES5 只有 **全局作用域** 和 **函数作用域**  
带来的一些影响
* 场景一：  
内部变量覆盖了全局变量  
```js
var temp = new Date();
function f(){
    console.log(temp);
    if(false){
        var temp = 1;
    }
}
f();
/*
undefined
*/
```
按照==变量提升==规则 上述代码可以转化为
```js
var temp = new Date();
function f(){
    //变量提升
    var temp;
    console.log(temp);
    if(false){
        temp = 1;
    }
}
f();
```
所以输出为**undefined**

* 场景二
```js
var s = "hello";
for(var i = 0; i < s.length;i++>){
    console.log(s[i]);
}
console.log(i);//5
```
**变量i**本意只是用来控制循环局部变量，但是循环结束后并没有消失 而是变成了*全局变量*。 

### 块级作用域写法
例1： 

```js
let temp = "hello";
{
    let temp = "world";
    console.log(temp);
}
console.log(temp);
/*
world
hello
*/
```

例2： 

```js
function f1() {
  let n = 5;
  if (true) {
    let n = 10;
  }
  console.log(n);
}
/*
5
*/
```

**ES6 允许块级作用域的任意嵌套**
```js
{
    {
        {
            {
            let insane = 'Hello World';
                { 
                    let insane = 'Hello World'
                }
            }
        }
    }
};
```
## 块级作用域和函数声明

**ES5** 函数声明 只能在==顶级作用域==和==函数作用域中==
```js
if(true){
    function f(){

    }
}
```
会报错**但是浏览器并没有遵循以上规则仍可以正常编译**

**ES6** 允许在块级作用域中声明函数 函数声明行为类似于let 在块级作用域外不可引用
```js
function f() {
    console.log("I'm in outside");
}

(function () {
    if (false) {
        function f() {
            console.log("I'm in inside");
        }
    }
    f();
}());
```
**ES5环境** 会输出 *I'm in inside*  

**ES6环境** 会输出 *I'm in outside* 块级作用域内声明的函数类似于let 

**ES5环境**实际运行的代码
```js
function f() {
    console.log("I'm in outside");
}

(function () {
    function f() 
    {
        console.log("I'm in inside");
    }
    if (false) {
        
    }
    f();
}());
```

==注意== 在符合es6的浏览器中运行是会报错的。浏览器的实现可以不遵守上面的规定，有自己的**行为方式**。

* 允许在块级作用域内声明函数
* 函数声明类似于var 会提升到全局作用域或者函数作用域的头部
* 同时 函数声明还会提升到块级作用域的头部

==注意==，上面三条规则只对 ES6 的浏览器实现有效**

```js
function f() {
    console.log("I'm in outside");
}

(function () {
    if (true) {
        f();
        function f() {
            console.log("I'm in inside");
        }
    }
}());
```
在ES6浏览器中的输出结果 *I'm in inside*

在ES6浏览器中实际运行的是以下代码
```js
function f() {
    console.log("I'm in outside");
}

(function () {
    //函数声明类似于var 会提升到全局作用域或者函数作用域的头部
    var f;
    if (true) {
        /*
        允许在块级作用域内声明函数
        同时 函数声明还会提升到块级作用域的头部
        */
         function f() {
            console.log("I'm in inside");
        }
        f();
    }
}());
```

==应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句==
```
// 函数声明语句
{
  let a = 'secret';
  function f() {
    return a;
  }
}

// 函数表达式
{
  let a = 'secret';
  let f = function () {
    return a;
  };
}
```

## const命令

### 基本用法
**const** 声明一个只读的常量，常量值不可改变。  
**const** 只声明 不赋值就会报错。   
**const**与**let**
* 只在声明的块级作用域内有效 
* 不存在变量提示 也存在==”暂时性死区“==

### 本质 
==const== 保护的只是变量的那个内存地址 不能被改动 而不是变量的值。也就是说复合型的数据**对象**和**数组** 不能保证它们数据结构不发生变化

## ES6 声明变量的六种方法
* var
* function
* let
* const
* import
* class

## 顶层对象属性
很难找到一种方法，可以在所有情况下，都取到顶层对象。下面是两种勉强可以使用的方法
```js
// 方法一
(typeof window !== 'undefined'
   ? window
   : (typeof process === 'object' &&
      typeof require === 'function' &&
      typeof global === 'object')
     ? global
     : this);

// 方法二
var getGlobal = function () {
  if (typeof self !== 'undefined') { return self; }
  if (typeof window !== 'undefined') { return window; }
  if (typeof global !== 'undefined') { return global; }
  throw new Error('unable to locate global object');
};
```




