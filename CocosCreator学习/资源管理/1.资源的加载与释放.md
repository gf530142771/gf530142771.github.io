<!-- TOC -->

- [资源的加载](#资源的加载)
    - [加载资源](#加载资源)
        - [1. cc.resource.load](#1-ccresourceload)
        - [2. cc.resource.loadDir 读取文件夹下的资源](#2-ccresourceloaddir-读取文件夹下的资源)
        - [3. cc.assetManager.loadRemote(  读取远程资源](#3-ccassetmanagerloadremote--读取远程资源)
        - [4.其他的方式 可查询官方APi](#4其他的方式-可查询官方api)
    - [资源释放](#资源释放)
        - [cc.assetManager.releaseAsset(asset: cc.Asset)](#ccassetmanagerreleaseassetasset-ccasset)
        - [cc.loader.releaseAll](#ccloaderreleaseall)
        - [5. 预加载](#5-预加载)

<!-- /TOC -->
## 资源的加载
2.4.3以后 使用Bundle来进行资源加载
```ts
export var resources: AssetManager.Bundle
```
### 加载资源

####  1. cc.resource.load
```ts
/*
@params paths           文件的路径 或者 文件路径的数组 当传入的为数组是,返回的是assets的数组
@params type            资源的类型 常用的包括cc.SpriteFrame cc.Texture2d 等具体可查阅官方api
@params onProgress      进度函数
@params onComplete      (error assets) error 未发生错误 error为null assets为单个cc.Asset或者cc.Asset的数组
*/
load<T extends cc.Asset>(paths: string, type: typeof cc.Asset, onProgress: (finish: number, total: number, item: RequestItem) => void, onComplete: (error: Error, assets: T) => void): void;
load<T extends cc.Asset>(paths: string[], type: typeof cc.Asset, onProgress: (finish: number, total: number, item: RequestItem) => void, onComplete: (error: Error, assets: Array<T>) => void): void;
load<T extends cc.Asset>(paths: string, onProgress: (finish: number, total: number, item: RequestItem) => void, onComplete: (error: Error, assets: T) => void): void;
load<T extends cc.Asset>(paths: string[], onProgress: (finish: number, total: number, item: RequestItem) => void, onComplete: (error: Error, assets: Array<T>) => void): void;
load<T extends cc.Asset>(paths: string, type: typeof cc.Asset, onComplete?: (error: Error, assets: T) => void): void;
load<T extends cc.Asset>(paths: string[], type: typeof cc.Asset, onComplete?: (error: Error, assets: Array<T>) => void): void;
load<T extends cc.Asset>(paths: string, onComplete?: (error: Error, assets: T) => void): void;
load<T extends cc.Asset>(paths: string[], onComplete?: (error: Error, assets: Array<T>) => void): void;
```
#### 2. cc.resource.loadDir 读取文件夹下的资源
```ts
/*
@params dir             文件夹的路径
@params type            资源的类型 不填则是读取所有类型的资源
@params onProgress      进度函数
@params onComplete      (error assets) error 未发生错误 error为null assets为cc.Asset的数组
*/
loadDir<T extends cc.Asset>(dir: string, type: typeof cc.Asset, onProgress: (finish: number, total: number, item: RequestItem) => void, onComplete: (error: Error, assets: Array<T>) => void): void;
loadDir<T extends cc.Asset>(dir: string, onProgress: (finish: number, total: number, item: RequestItem) => void, onComplete: (error: Error, assets: Array<T>) => void): void;
loadDir<T extends cc.Asset>(dir: string, type: typeof cc.Asset, onComplete: (error: Error, assets: Array<T>) => void): void;
loadDir<T extends cc.Asset>(dir: string, type: typeof cc.Asset): void;
loadDir<T extends cc.Asset>(dir: string, onComplete: (error: Error, assets: Array<T>) => void): void;
loadDir<T extends cc.Asset>(dir: string): void;
```

#### 3. cc.assetManager.loadRemote(  读取远程资源
```ts
/*
@params url         远程地址
@params options         
@params onComplete
@example 
cc.assetManager.loadRemote('http://www.cloud.com/test1.jpg', (err, texture) => console.log(err));
cc.assetManager.loadRemote('http://www.cloud.com/test2.mp3', (err, audioClip) => console.log(err));
cc.assetManager.loadRemote('http://www.cloud.com/test3', { ext: '.png' }, (err, texture) => console.log(err));
*/
loadRemote<T extends cc.Asset>(url: string, options: Record<string, any>, onComplete: (err: Error, asset: T) => void): void;
loadRemote<T extends cc.Asset>(url: string, onComplete: (err: Error, asset: T) => void): void;
loadRemote<T extends cc.Asset>(url: string, options: Record<string, any>): void;
loadRemote<T extends cc.Asset>(url: string): void;
```

#### 4.其他的方式 可查询官方APi
* loadScene
* getInfoWithPath
* getDirWithPath

### 资源释放
#### cc.assetManager.releaseAsset(asset: cc.Asset) 
释放单个资源
#### cc.loader.releaseAll  
释放所有资源 慎用

#### 5. 预加载 
大部分加载接口都有与之对应的预加载方法 
* preload  
* preloadDir
* preloadScene

预加载和加载的区别：
1. 预加载只会下载资源 但是不会解析资源和初始化
2. 预加载的在加载过程中 收到的限制更多，比如下载同时并发数更小
3. 预加载的下载优先级更低，一般是放在最后下载
4. 预加载由于没有做任何解析，不会返回任何可用资源

因为预加载没有去解析资源，所以需要在预加载完成后配合加载接口进行资源的解析和初始化，来完成资源加载。例如：
```js
cc.resources.preload('images/background', cc.SpriteFrame);

// wait for while 
cc.resources.load('images/background', cc.SpriteFrame, function (err, spriteFrame) {
    spriteFrame.addRef();
    self.getComponent(cc.Sprite).spriteFrame = spriteFrame;
});
```

**注意**  
加载 不需要等待 预加载完成即可使用 ， 加载只是会直接复用预加载已经下载好的内容 从而缩短下载事件而已


