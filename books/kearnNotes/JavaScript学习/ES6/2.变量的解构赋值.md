<!-- TOC -->

- [变量的解构赋值](#变量的解构赋值)
    - [数组的解构赋值](#数组的解构赋值)
    - [对象的解构赋值](#对象的解构赋值)
    - [字符串的赋值](#字符串的赋值)
    - [数值和布尔值的解构赋值](#数值和布尔值的解构赋值)
    - [函数的解构赋值](#函数的解构赋值)

<!-- /TOC -->
// 
## 变量的解构赋值
### 数组的解构赋值
* 只要等号两边的模式相同，左边的变量就会被赋予对应的值。
* 如果解构不成功，变量的值就等于==undefined==。
* 不完全解构也能赋值成功
* 也可以设置默认值 但是需要注意的是只有判断数组当前位置的成员严格等于即=== undefined时才会使用默认值  

**注意 等号的右边必须是可遍历的结构才能使用此类赋值方法**  

```js
let [a, [b, c], d = 5, e = 1, f] = [1, [2, 3, 5], undefined, null];
console.log(a, b, c, d, e, f);
/*
1 2 3 5 null undefine
*/
```

### 对象的解构赋值
* 变量名与属性名一致时，可以使用省略的写法
* 变量名与属性名不一致时，要使用完整的写法
* 结构不成功 默认为==undefined==
* 不用拘泥于顺序 是按照**属性名**来查找

```js
let obj = {
    a: 10,
    b: 100
}

let { a, b: b2, c } = obj;//===let {a : a,b:b2,c:c}= obj;
console.log(a, b2, c);//10 100 undefined
console.log(b);//报错 b is not defined
```
看一个更复杂的例子
```js
let obj2 = {
    a: 10,
    b: {
        c: 100,
        d: [1000, 2000, 3000]
    },
    e: [5000, 6000, 7000]
}

let { b: { d: [x1, x2, x3] }, e: [x4, x5], e: x6, b: x7,x8 = 10 } = obj2;
console.log(x1, x2, x3, x4, x5, x6, x7,x8);//1000 2000 3000 5000 6000 [ 5000, 6000, 7000 ] { c: 100, d: [ 1000, 2000, 3000 ],10 }
```

### 字符串的赋值
其实就是字符转装换成了一个类似数组的对象
```js
const [a, b, c, d, e] = "hello";
console.log(a, b, c, d, e);//h e l l o
```

### 数值和布尔值的解构赋值
本质是先转为对象
```js
let { toString: s } = 123;
console.log(s);//[Function: toString]
```

### 函数的解构赋值
```js
function move({x = 0, y = 0} = {}) {
  return [x, y];
}

move({x: 3, y: 8}); // [3, 8]
move({x: 3}); // [3, 0]
move({}); // [0, 0]
move(); // [0, 0]
```




