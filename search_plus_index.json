{"./":{"url":"./","title":"Introduction","keywords":"","body":" MarkdownNotes 介绍 个人笔记记录 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"AndroidStudio常见问题解决/":{"url":"AndroidStudio常见问题解决/","title":"AndroidStudio常见问题解决","keywords":"","body":" AndroidStudio常见问题解决 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"AndroidStudio常见问题解决/常见问题.html":{"url":"AndroidStudio常见问题解决/常见问题.html","title":"常见问题","keywords":"","body":" 一.Gradle Plugin Version和Gradle Version版本对应关系 Gradle Plugin Version Gradle Version 1.0.0 - 1.1.3 2.2.1 - 2.3 1.2.0 - 1.3.1 2.2.1 - 2.9 1.5.0 2.2.1 - 2.13 2.0.0 - 2.1.2 2.10 - 2.13 2.1.3 - 2.2.3 2.14.1+ 2.3.0+ 3.3+ 3.0.0+ 4.1+ 3.1.0+ 4.4+ 3.2.0 - 3.2.1 4.6+ 3.3.0 - 3.3.3 4.10.1+ 3.4.0 - 3.4.3 5.1.1+ 3.5.0 - 3.5.4 5.4.1+ 3.6.0 - 3.6.4 5.6.4+ 4.0.0+ 6.1.1+ 4.1.0+ 6.5+ 二.关于gradle 下载失败的问题 1.切换国内源 阿里云云效Maven 参照官方配置指南配置即可 2.科学上网 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"CocosCreatorMVC框架结构设计/":{"url":"CocosCreatorMVC框架结构设计/","title":"CocosCreatorMVC框架结构设计","keywords":"","body":" 说明 CocosCreator MVC框架设计 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"CocosCreatorMVC框架结构设计/1.设计总纲.html":{"url":"CocosCreatorMVC框架结构设计/1.设计总纲.html","title":"1.设计总纲","keywords":"","body":" 设计思路 1.MVC简单介绍 Model数据模块 数据更新 View界面显示 主要负责显示数据和接收用户操作 Controller控制模块 主要功能是处理用户的请求 处理业务逻辑 所有的通信都是单向的 基本设计设计思路 淡化Controller的业务逻辑操作 每一个View和Model之间增加一个中介者Mediator来处理业务逻辑Mediator和View一一对应使用中介者模式 behavor 通过命令来控制Model使用命令模式 Model 的数据发生改变通过广播的形式来通知 所有的Model通过ModelManager管理 View 通过发送 Event 来通知 Mediator 进行业务逻辑处理 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"CocosCreator学习/":{"url":"CocosCreator学习/","title":"CocosCreator学习","keywords":"","body":" 说明 cocoscreator 2.4版本学习笔记 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"CocosCreator学习/1.资源的加载与释放.html":{"url":"CocosCreator学习/1.资源的加载与释放.html","title":"1.资源的加载与释放","keywords":"","body":" 资源加载与释放的优化 参考文档 一.CocosCreator的资源加载机制 1.存储方式 资源加载完成后 会已 {uuid:cc.Asset} 的形式被缓存到 cc.asssetManager.assets中 避免发生重复加载 资源可以通过自动释放和手动释放的方式来进行释放 cc.assetManager管理资源的行为和信息，包括加载，释放等。 2.引用计数法 cocos2d-x一种常用的内存管理计数，基本原理将资源的引用次数保存起来，每次释放计数减1，当计数为0时 释放掉资源 cocoscreator的资源函数 addRef() 增加引用计数 decRef(autoRelease) 减少引用计数 注意: AssetManager只会自动统计==静态引用== 开发者==动态引用==的资源需要自己加以控制并释放 3.静态引用和动态引用 静态引用 (直接在编辑器里使用的资源) 在编辑器里使用的资源 引擎会自动分析出以来资源的列表 这样的资源引用 被视为 ==静态引用== 引擎对资源的静态引用的统计方式为： 在静态加载某个资源时，引擎会在底层加载管线中记录该资源所有直接依赖资源的信息，并将所有直接依赖资源的引用计数加 1，然后将该资源的引用计数初始化为 0 在释放资源时，取得该资源之前记录的所有直接依赖资源信息，并将所有依赖资源的引用计数减 1 只有资源的引用计数为0时才会被自动释放 图解 场景的自动释放 动态引用 动态加载resources中的资源 cc.resources.load(\"HelloWorld\", cc.SpriteFrame, (err, assets: cc.SpriteFrame) => { this.sprite.spriteFrame = assets; console.log(cc.assetManager.assets); console.log(\"spriteFrame.refCount : \" + this.sprite.spriteFrame.refCount); }); 动态加载bundle目录中的资源 cc.assetManager.loadBundle(\"bundle\", (err: Error, bundle: cc.AssetManager.Bundle) => { bundle.load(\"HelloWorld\", cc.SpriteFrame, (err, assets: cc.SpriteFrame) => { this.sprite.spriteFrame = assets; console.log(cc.assetManager.assets); console.log(\"spriteFrame.refCount : \" + this.sprite.spriteFrame.refCount); }); }); 动态引用资源的释放 通过decRef()的方法 使引用计数-1 creator会根据计数自动进行释放资源。 使用assetManager 的相关接口来手动释放资源cc.assetManager.releaseAsset(texture); 注意： release系列接口 会直接释放资源 不会进行检查 二.cocoscreator的资源释放流程 1.assets相关源码 2.基本流程图 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"CocosCreator学习/编辑器扩展/":{"url":"CocosCreator学习/编辑器扩展/","title":"编辑器扩展","keywords":"","body":" MarkdownNotes 介绍 个人笔记记录 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"CocosCreator学习/编辑器扩展/1.扩展包的安装与结构.html":{"url":"CocosCreator学习/编辑器扩展/1.扩展包的安装与结构.html","title":"1.扩展包的安装与结构","keywords":"","body":" 扩展包的结构与安装 一.扩展包安装与卸载 全局扩展包安装 CocosCreator安装目录.CocosCreator\\packages 项目扩展包安装 项目路径.CocosCreator\\packages 卸载 直接从packages删除扩展包目录即可 二.目录结构 MyProject |--assets |--packages |--插件名称 |--package.json |--main.js var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"CocosCreator学习/编辑器扩展/2.扩展包结构与参数解析.html":{"url":"CocosCreator学习/编辑器扩展/2.扩展包结构与参数解析.html","title":"2.扩展包结构与参数解析","keywords":"","body":" 扩展包结构与参数解析 创建并安装扩展包 创建如下结构的目录结构 放入项目的packages文件夹下 hello-world |--main.js |--package.json package.json参数解析 { \"name\": \"hello-world\", \"version\": \"0.0.1\", \"description\": \"一份简单的扩展包\", \"author\": \"Cocos Creator\", \"main\": \"main.js\", \"main-menu\": { \"Packages/Hello World\": { \"message\": \"hello-world:say-hello\" } } } 参数 介绍 name String-扩展包名称(必须),保证全局唯一性 version String-扩展包的版本号(必须) description String-扩展包的描述(可选) author String-作者(可选) main String-入口程序(可选) main-menu Object-主菜单定义 在编辑器的主菜单显示相应按钮(可选)参考主菜单字段参考 panel Obejct 用于注册开发面板参考panel字段参考 reload Obejct 定制扩展包自动重载的文件监控规则 runtime-resource Obejct 资源映射,将扩展的资源映射到资源管理器 scene-script Obejct 字段用于声明一个扩展包内的脚本，在该脚本中可以使用引擎 API，并访问当前场景中的节点和组件。调用引擎API和项目脚本 范例: runtime-resource 资源映射 \"runtime-resource\": { \"path\": \"path/to/runtime-resource\", \"name\": \"shared-resource\" } 上述声明会将 projectPath/packages/myPackage/path/to/runtime-resource 路径下的全部资源都映射到资源管理器中，显示为 [myPackage]-[shared-resource]。 main-menu 扩展菜单路径 { \"main-menu\": { \"Examples/FooBar\": { \"message\": \"my-package:foo\" }, \"Examples/FooBar/Bar\": { \"message\": \"my-package:bar\" } } } 在这个例子中，我们先在主菜单中注册了一份菜单路径 Examples/Foobar，这之后我们又注册了 Examples/Foobar/Bar，而第二个菜单路径的注册要求 Foobar 的类型为一个分级子菜单（submenu），然而由于上一次的注册已经将 Foobar 的类型定义为菜单选项（menu-item），从而导致了注册失败。 panelpanel (Object) 用于面板注册。面板注册的键值（Key）是一个以 panel 开头的字符串，字符串后面可跟上后缀名用于多面板的注册。注册完成的面板，将会生成以 ${包名}${面板后缀名} 为组合的面板 ID。通常情况下如果我们只注册一个面板，就不需要带后缀名，面板 ID 默认就是插件包的名字。但如果是注册多个面板，就需要带后缀名，以便区分。关于多面板注册，这里我们提供了一个简单的例子，在 package.json 中： { \"name\": \"simple-package\", \"panel\": { \"main\": \"panel/index.js\", \"type\": \"dockable\", \"title\": \"Simple Panel\", \"width\": 400, \"height\": 300 }, \"panel.02\": { \"main\": \"panel.02/index.js\", \"type\": \"dockable\", \"title\": \"Simple Panel 02\", \"width\": 400, \"height\": 300 }, } 入口程序 初始化扩展包 执行后台操作程序 调用CocosCreator主进程中的方法 管理扩展面板的开启和关闭 简单范例 'use strict'; module.exports = { load () { Editor.log('package loaded'); }, unload () { Editor.log('package unloaded'); }, }; 生命周期 load当扩展包正确载入后，将会执行用户入口程序中的 load 函数。我们可以在这里做一些关于扩展包本身的初始化操作。 unload当扩展包卸载进行到最后阶段，将会执行用户入口程序中的 unload 函数。我们可以在这里做一些扩展包卸载前的清理操作。 加载和卸载注意事项Cocos Creator 支持在编辑器运行时动态的添加和删除扩展包，所以要注意如果扩展包依赖编辑器其他模块的特定工作状态时，必须在 load 和 unload 里进行妥善处理。如果插件的动态加载和卸载导致其他模块工作异常时，扩展包的用户总是可以选择关闭编辑器后重新启动。 IPC 消息注册在入口程序中添加 messages 字段，可以让扩展包在加载的时候进行主进程的 IPC 消息注册。样例如下： 'use strict'; module.exports = { messages { 'foo-bar' ( event ) { Editor.log('hello foobar'); }, 'scene:saved' ( event ) { Editor.log('scene saved!'); }, }, }; var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"CocosCreator学习/编辑器扩展/3.进程间的通讯.html":{"url":"CocosCreator学习/编辑器扩展/3.进程间的通讯.html","title":"3.进程间的通讯","keywords":"","body":" 进程间通信 参考IPC简介 一. 发送消息 主进程向面板panel发送消息 Editor.Ipc.sendToPanel('panelID', 'message' [, ...args, callback, timeout]) 参数： panelID面板的ID 对于单面板扩展包来说 就是插件的包名 message是 IPC 消息的全名，如 do-some-work，我们推荐在定义 IPC 消息名时使用 - 来连接单词，而不是使用驼峰或下划线。 args可选从第三个参数开始，可以定义数量不定的多个传参，用于传递更具体的信息到面板进程。 callback可选 在传参后面可以添加回调方法，在面板进程中接受到 IPC 消息后可以选择向主进程发送回调，并通过 callback 回调方法进行处理。回调方法的参数第一个是 error（如果没有错误则传入 null），之后才是传参。 timeout 可选回调超时，只能配合回调方法一起使用，如果规定了超时，在消息发送后的一定时间内没有接到回调方法，就会触发超时错误。如果不指定超时，则默认的超时设置是 5000 毫秒。 面板向主进程发送消息 Editor.Ipc.sendToMain('message', [, ...args, callback, timeout]) 其他消息发送方法 任意进程对主进程Editor.Ipc.sendToMain 任意进程对面板Editor.Ipc.sendToPanel 任意进程对编辑器主窗口（也就是对主窗口里的所有渲染进程广播）Editor.Ipc.sendToMainWin 任意进程对所有窗口（对包括弹出窗口在内的所有窗口渲染进程广播）Editor.Ipc.sendToWins 任意进程对所有进程广播Editor.Ipc.sendToAll 二. 接收消息 要在主进程或渲染进程中接受 IPC 消息，最简单的办法是在声明对象的 messages 字段中注册以 IPC 消息为名的消息处理方法。 面板渲染进程消息监听 Editor.Panel.extends({ //... messages: { 'my-message': function (event, ...args) { //do some work } } }); 主进程消息监听 module.exports = { //... messages: { 'my-message': function (event, ...args) { //do some work } } } 其他消息监听方式 渲染进程中： require('electron').ipcRenderer.on('foobar:message', function(event, args) {}); 主进程中： require('electron').ipcMain.on('foobar:message', function(event, args) {}); 三. 向消息来源发送回调 假如我们从主进程发送了一个消息： //packages/foobar/main.js Editor.Ipc.sendToPanel('foobar', 'greeting', 'How are you?', function (error, answer) { Editor.log(answer); }); 在面板监听消息的方法中，我们可以使用 event.reply 来发送回调： Editor.Panel.extends({ //... messages: { 'greeting': function (event, question) { console.log(question); //How are you? if (event.reply) { //if no error, the first argument should be null event.reply(null, 'Fine, thank you!'); } } } }); 四. 消息超时处理 Editor.Ipc.sendToMain('foobar:greeting', function (error, answer) { if ( error && error.code === 'ETIMEOUT' ) { //check the error code to confirm a timeout Editor.error('Timeout for ipc message foobar:greeting'); return; } Editor.log(answer); }); var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"CocosCreator学习/编辑器扩展/4.调用引擎API和项目脚本.html":{"url":"CocosCreator学习/编辑器扩展/4.调用引擎API和项目脚本.html","title":"4.调用引擎API和项目脚本","keywords":"","body":" 调用引擎 API 和项目脚本 在插件中可以声明一个特殊的脚本文件（场景脚本），该脚本和项目中的脚本 （assets 目录下的脚本）具有相同的环境，也就是说在这个脚本里可以调用引擎 API 和其他项目脚本，实现 遍历场景中的节点，获取或改动数据 调用项目中的其他脚本完成工作 注册场景脚本 package.json的 scene-script 字段 \"scene-script\": \"scene-walker.js\" 编写场景脚本 module.exports = { 'get-canvas-children': function (event) { var canvas = cc.find('Canvas'); Editor.log('children length : ' + canvas.children.length); if (event.reply) { event.reply(null, canvas.children.length); } } }; 扩展包向场景脚本发送消息 Editor.Scene.callSceneScript('foobar', 'get-canvas-children', function (err, length) { console.log(`get-canvas-children callback : length - ${length}`); }); var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"CocosCreator学习/编辑器扩展/字段参考.html":{"url":"CocosCreator学习/编辑器扩展/字段参考.html","title":"字段参考","keywords":"","body":" 主菜单字段参考 字段名 类型 简介 message String IPC小子字段，点击菜单后，发送该字段到主进程中 command String 直接在主进程中运行全局函数 与message不能共存 params Array 消息参数，使发送的消息带有参数 accelerator String 快捷键注册字段,具体敌营规则 参考Accelerator icon String 为菜单定义icon visible Boolean 控制菜单是否隐藏 enabled Boolean 控制菜单是否可点击 面板字段参考 字段名 类型 简介 main String 面板入口文件 可以使js也可以是html 取决于type type 为 simple时读取html,否则读入js type String 面板类型 title String 面板标题，如果面板类型为 dockable，面板标题将会显示在 Tab 上。 icon String 面板 Tab 上显示的图标 resizable Boolean 设置面板在独立窗口状态下时是否可以改变大小 width Interger 设置面板窗口的初始宽度 height Interger 设置面板窗口的初始高度 min-widtg Interger 设置面板窗口的最小宽度 min-height Interger 设置面板窗口的最小高度 max-width Interger 设置面板窗口的最大宽度 max-height Interger 设置面板窗口的最大高度 面板type类型 dockable：该面板为标准的编辑器面板，可以自由的在编辑器内停靠。 float：该面板为浮动面板，不能停靠在编辑器中。 fixed-size：该面板和浮动面板功能相似，不同之处在于他的窗口大小是固定的。 quick：该面板和浮动面功能相似，不同之处在于当他失去焦点后将会自动关闭。 simple：简单面板拥有独立窗口，通过读取用户自定义的 html 文件展示界面。 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"JavaScript学习/":{"url":"JavaScript学习/","title":"JavaScript学习","keywords":"","body":" JavaScript学习记录 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"JavaScript学习/RegExp正则表达式.html":{"url":"JavaScript学习/RegExp正则表达式.html","title":"RegExp正则表达式","keywords":"","body":" 正则表达式(RegExp) 一.创建 //使用RegExp的构造函数来创建 let regExpA= new RegExp('abc'); //使用 / /语法创建 let regExpB = /abc/; 二.正则表达式的属性和模式 属性 属性 描述 global 返回布尔值，表示是否设置了g修饰符 ignoreCase 返回布尔值,表示是否设置了i修饰符 lastIndex 返回下一次搜索的位置 multiline 返回布尔值，表示是否设置了m修饰符 source 返回正则表达式的字符串形式(不包含反斜杠) 注意: lastIndex为可读写属性，其他均为只读属性 模式 模式 描述 g 默认情况下 第一次匹配成功后 正则表达式停止向下匹配 g表示全局匹配 加上以后将匹配所有符合条件的结果 i 默认情况下区分大小写 i表示忽略大小写 m m修饰符表示多行模式 会忽略字符创的头部或者尾部的换行符 三.正则表达式的3个方法 test() 检索字符串中的指定值,返回类型为布尔值 exec() 检索字符串中的指定值,返回一个数组,没有则返回null compile() 修改正则表达式let a = /abc/ig let string1 = \"123ABC21ABC23\"; console.log(a.test(string1));//检测字符串中的指定值,返回为布尔值 console.log(a.exec(string1));//检测字符创中的指定值,返回数组 /* true, [ 'ABC', index: 8, input: '123ABC21ABC23', groups: undefined ] */ 四.正则表达式基础 1. 直接量字符 字符 匹配 \\o 查找null字符 \\n 换行符 \\f 换页符 \\r 回车符 \\t 制表符 \\v 垂直制表符 \\xxx 八进制的字符 \\xdd 十六进制数dd规定的字符 \\uxxx Unicode 2. 字符类 字符 匹配 . 查找单个字符，除了换行和行结束符 [...] 方框内的任意符 ... 不在方框内的任意字符 \\w 单词字符 \\W 非单词字符 \\d 数字字符 \\D 非数字字符 \\s 空白字符 \\S 非空白字符 \\b 匹配单词边界 \\B 匹配非单词边界 3.方括号的使用方法 示例 表达式 描述 [abc] 查找方框内的任何字符 [ ^abc ] 不在方框内的任意字符 [0-9] 查找0-9的数字 [a-z] 小写a到小写z之间的所有字符 [A-Z] 大写A到大写Z之间的所有字符 [A-z] 大写A到小写z之间的所有字符 4.量词 (重复字符语法 非贪婪重复) 量词 描述 n+ 匹配至少含有一个n的字符串 n* 任何包含0或者多个n的字符串 n? 任何包含0个或一个n的字符串 n{X} 包含X个n的字符串 n{X,Y} 包含X到Y个n的字符串 n(X,) 至少包含X个n的字符串 (?=n) 匹配任意后面紧跟n的字符串 (?!n) 匹配任意后面不紧跟n的字符串 练习 // 手机号匹配 let phoneNUms = \"18730870726 1761345689 18730870729 dsfsdfds 193488588696 135777777777777\"; let phoneNumRegRxp = /(1{1}[3|5|8]\\d{9}(?= ))/gm console.log(phoneNUms.match(phoneNumRegRxp)); /* [ '18730870726', '18730870729' ] */ //子表达式 let s = \"titletext\"; let r = /()\\w*\\1/g console.log(s.match(r)); /* [ 'title', 'text' */ //屏蔽词 let biWords = [\"王八蛋\", \"傻逼\", \"Fuck\"]; let regStr = \"(\" + biWords.join(\")|(\") + \")\"; console.log(regStr); let regRxpBi = new RegExp(regStr, \"gi\"); console.log(\"你个王八蛋，臭傻逼\".replace(regRxpBi, \"*\")); /* (王八蛋)|(傻逼)|(Fuck) 你个*，臭* */ var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"JavaScript学习/ES6/":{"url":"JavaScript学习/ES6/","title":"ES6","keywords":"","body":"ES6 参考地址 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"JavaScript学习/ES6/1.let和const.html":{"url":"JavaScript学习/ES6/1.let和const.html","title":"1.let和const","keywords":"","body":"let命令 基本用法 与var的对照 块级作用域 块级作用域存在的意义 块级作用域写法 块级作用域和函数声明 const命令 基本用法 本质 ES6 声明变量的六种方法 顶层对象属性 基本用法 用于声明变量 let a = 10; console.log(10); /* 10 */ 与var的对照 不存在变量的提升console.log(temp); var temp; /* undefined */ console.log(temp); let temp; /* 报错 Cannot access 'temp' before initialization */ 不允许重复声明 ```js var a = 10; var a = 100; console.log(a); / 100 / let b = 10; let b = 100; / 报错 Identifier 'b' has already been declared / * 暂时性死区 只要块级作用域内存在**let**命令 那么它所声明的变量绑定这个区域 不受外部的的影响 ```js var temp = 10; if(true){ temp = 100 let temp; } /* 报错 annot access 'temp' before initialization */ 上面代码报错只要块作用域中 存在let命令 那么变量在没有被let声明之前都是不可用的这在语法上就叫做 暂时性死区 块级作用域 块级作用域存在的意义 ES5 只有 全局作用域 和 函数作用域带来的一些影响 场景一：内部变量覆盖了全局变量 var temp = new Date(); function f(){ console.log(temp); if(false){ var temp = 1; } } f(); /* undefined */ 按照==变量提升==规则 上述代码可以转化为 var temp = new Date(); function f(){ //变量提升 var temp; console.log(temp); if(false){ temp = 1; } } f(); 所以输出为undefined 场景二 var s = \"hello\"; for(var i = 0; i ){ console.log(s[i]); } console.log(i);//5 变量i本意只是用来控制循环局部变量，但是循环结束后并没有消失 而是变成了全局变量。 块级作用域写法 例1： let temp = \"hello\"; { let temp = \"world\"; console.log(temp); } console.log(temp); /* world hello */ 例2： function f1() { let n = 5; if (true) { let n = 10; } console.log(n); } /* 5 */ ES6 允许块级作用域的任意嵌套 { { { { let insane = 'Hello World'; { let insane = 'Hello World' } } } } }; 块级作用域和函数声明 ES5 函数声明 只能在==顶级作用域==和==函数作用域中== if(true){ function f(){ } } 会报错但是浏览器并没有遵循以上规则仍可以正常编译 ES6 允许在块级作用域中声明函数 函数声明行为类似于let 在块级作用域外不可引用 function f() { console.log(\"I'm in outside\"); } (function () { if (false) { function f() { console.log(\"I'm in inside\"); } } f(); }()); ES5环境 会输出 I'm in inside ES6环境 会输出 I'm in outside 块级作用域内声明的函数类似于let ES5环境实际运行的代码 function f() { console.log(\"I'm in outside\"); } (function () { function f() { console.log(\"I'm in inside\"); } if (false) { } f(); }()); ==注意== 在符合es6的浏览器中运行是会报错的。浏览器的实现可以不遵守上面的规定，有自己的行为方式。 允许在块级作用域内声明函数 函数声明类似于var 会提升到全局作用域或者函数作用域的头部 同时 函数声明还会提升到块级作用域的头部 ==注意==，上面三条规则只对 ES6 的浏览器实现有效** function f() { console.log(\"I'm in outside\"); } (function () { if (true) { f(); function f() { console.log(\"I'm in inside\"); } } }()); 在ES6浏览器中的输出结果 I'm in inside 在ES6浏览器中实际运行的是以下代码 function f() { console.log(\"I'm in outside\"); } (function () { //函数声明类似于var 会提升到全局作用域或者函数作用域的头部 var f; if (true) { /* 允许在块级作用域内声明函数 同时 函数声明还会提升到块级作用域的头部 */ function f() { console.log(\"I'm in inside\"); } f(); } }()); ==应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句== // 函数声明语句 { let a = 'secret'; function f() { return a; } } // 函数表达式 { let a = 'secret'; let f = function () { return a; }; } const命令 基本用法 const 声明一个只读的常量，常量值不可改变。const 只声明 不赋值就会报错。const与let 只在声明的块级作用域内有效 不存在变量提示 也存在==”暂时性死区“== 本质 ==const== 保护的只是变量的那个内存地址 不能被改动 而不是变量的值。也就是说复合型的数据对象和数组 不能保证它们数据结构不发生变化 ES6 声明变量的六种方法 var function let const import class 顶层对象属性 很难找到一种方法，可以在所有情况下，都取到顶层对象。下面是两种勉强可以使用的方法 // 方法一 (typeof window !== 'undefined' ? window : (typeof process === 'object' && typeof require === 'function' && typeof global === 'object') ? global : this); // 方法二 var getGlobal = function () { if (typeof self !== 'undefined') { return self; } if (typeof window !== 'undefined') { return window; } if (typeof global !== 'undefined') { return global; } throw new Error('unable to locate global object'); }; var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"JavaScript学习/ES6/2.变量的解构赋值.html":{"url":"JavaScript学习/ES6/2.变量的解构赋值.html","title":"2.变量的解构赋值","keywords":"","body":"变量的解构赋值 数组的解构赋值 对象的解构赋值 字符串的赋值 数值和布尔值的解构赋值 函数的解构赋值 数组的解构赋值 只要等号两边的模式相同，左边的变量就会被赋予对应的值。 如果解构不成功，变量的值就等于==undefined==。 不完全解构也能赋值成功 也可以设置默认值 但是需要注意的是只有判断数组当前位置的成员严格等于即=== undefined时才会使用默认值 注意 等号的右边必须是可遍历的结构才能使用此类赋值方法 let [a, [b, c], d = 5, e = 1, f] = [1, [2, 3, 5], undefined, null]; console.log(a, b, c, d, e, f); /* 1 2 3 5 null undefine */ 对象的解构赋值 变量名与属性名一致时，可以使用省略的写法 变量名与属性名不一致时，要使用完整的写法 结构不成功 默认为==undefined== 不用拘泥于顺序 是按照属性名来查找 let obj = { a: 10, b: 100 } let { a, b: b2, c } = obj;//===let {a : a,b:b2,c:c}= obj; console.log(a, b2, c);//10 100 undefined console.log(b);//报错 b is not defined 看一个更复杂的例子 let obj2 = { a: 10, b: { c: 100, d: [1000, 2000, 3000] }, e: [5000, 6000, 7000] } let { b: { d: [x1, x2, x3] }, e: [x4, x5], e: x6, b: x7,x8 = 10 } = obj2; console.log(x1, x2, x3, x4, x5, x6, x7,x8);//1000 2000 3000 5000 6000 [ 5000, 6000, 7000 ] { c: 100, d: [ 1000, 2000, 3000 ],10 } 字符串的赋值 其实就是字符转装换成了一个类似数组的对象 const [a, b, c, d, e] = \"hello\"; console.log(a, b, c, d, e);//h e l l o 数值和布尔值的解构赋值 本质是先转为对象 let { toString: s } = 123; console.log(s);//[Function: toString] 函数的解构赋值 function move({x = 0, y = 0} = {}) { return [x, y]; } move({x: 3, y: 8}); // [3, 8] move({x: 3}); // [3, 0] move({}); // [0, 0] move(); // [0, 0] var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"JavaScript学习/ES6/3.字符串扩展.html":{"url":"JavaScript学习/ES6/3.字符串扩展.html","title":"3.字符串扩展","keywords":"","body":"字符串扩展 字符Unicode的表示法 新增方法 模板字符串 模板字符串 字符Unicode的表示法 ES6 加强了unicode 的支持ES5 这种表示法只限于码点在\\u0000~\\uFFFF之间的字符。超出这个范围的字符，必须用两个双字节的形式表示。 ES6 对这一点做出了改进，只要将码点放入大括号，就能正确解读该字符。 codePointAt() Javascript 内部 字符以UTF-16格式存储，每个字符2个字节 codePointAt 能正确处理四个字节存储的字符 let s = \"𠮷a\"; console.log(s.codePointAt(0)); console.log(s.codePointAt(1)); console.log(s.codePointAt(2)); /* 134071 57271 9 */ \"𠮷a\"是三个字符codePointAt方法的参数，仍然是不正确的。比如，上面代码中，字符a在字符串s的正确位置序号应该是 1，但是必须向codePointAt方法传入 2。解决这个问题的一个办法是使用for...of循环，因为它会正确识别 32 位的 UTF-16 字符。 let s = \"𠮷a\"; for (let code of s) { console.log(code); } /* 𠮷 a */ at()这个方法可以通过垫片库实现 可以识别 Unicode 编号大于0xFFFF的字符，返回正确的字符。 新增方法 includes()返回bool值 表示是否找到了字符串 startWith()返回布尔值，表示参数字符串是否在原字符串的头部。 endsWith()返回布尔值，表示参数字符串是否在原字符串的尾部。 let s2 = \"hello world\"; console.log(s2.includes(\"world\"));//true console.log(s2.startsWith(\"hello\"));//true console.log(s2.endsWith(\"ad\"));//false //这三个方法都支持第二个参数，表示开始搜索的位置。 s.startsWith('world', 6) // true s.endsWith('hello', 5) // true s.includes('hello', 6) // false repeat()返回一个重复那次的字符串 'x'.repeat(3) // \"xxx\" 'hello'.repeat(2) // \"hellohello\" 'na'.repeat(0) // \"\" // 参数如果是小数，会被取整。 'na'.repeat(2.9) // \"nana\" padStart() padEnd()字符串补全 ```js 'x'.padStart(5, 'ab') // 'ababx' 'x'.padStart(4, 'ab') // 'abax' 'x'.padEnd(5, 'ab') // 'xabab' 'x'.padEnd(4, 'ab') // 'xaba' // 如果省略第二个参数，默认使用空格补全长度。 'x'.padStart(4) // ' x' 'x'.padEnd(4) // 'x ' ### 模板字符串 模板字符串（template string）是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。 ```js // 普通字符串 `In JavaScript '\\n' is a line-feed.` // 多行字符串 `In JavaScript this is not legal.` console.log(`string text line 1 string text line 2`); // 字符串中嵌入变量 模板字符串中嵌入变量，需要将变量名写在${}之中。 let name = \"Bob\", time = \"today\"; `Hello ${name}, how are you ${time}?` // 大括号内部可以放入任意的 JavaScript 表达式，可以进行运算，以及引用对象属性。 let x = 1; let y = 2; `${x} + ${y} = ${x + y}` // \"1 + 2 = 3\" `${x} + ${y * 2} = ${x + y * 2}` // \"1 + 4 = 5\" let obj = {x: 1, y: 2}; `${obj.x + obj.y}` // \"3\" // 模板字符串之中还能调用函数。 function fn() { return \"Hello World\"; } `foo ${fn()} bar` // foo Hello World bar // 模板字符串甚至还能嵌套。 let addrs = [{ first: 1, last: 2 }, { first: 3, last: 4 }]; const tmpl = addrs => ` ${addrs.map(addr => ` ${addr.first} ${addr.last} `).join('')} `; console.log(tmpl(addrs)); /* 1 2 3 4 */ 模板字符串 function compile(template) { const evalExpr = //g; const expr = //g; template = template .replace(evalExpr, '`); \\n echo( $1 ); \\n echo(`') .replace(expr, '`); \\n $1 \\n echo(`'); template = 'echo(`' + template + '`);'; console.log(template); let script = `(function parse(data){ let output = \"\"; function echo(html){ output += html; } ${template} return output; })`; return script; } let parse = eval(compile(template)); console.log(parse({ supplies: [\"broom\", \"mop\", \"cleaner\"] })); var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"JavaScript学习/ES6/4.数值扩展.html":{"url":"JavaScript学习/ES6/4.数值扩展.html","title":"4.数值扩展","keywords":"","body":"数值扩展 二进制和八进制 新增方法 新增常量 二进制和八进制 console.log(0b1101.toString(10));//13 console.log(0o17.toString(10));//15 新增方法 Number.isFinite()检查一个数值是否是有限的 参数不是数值类型通通返回falseNumber.isFinite(15); // true Number.isFinite(0.8); // true Number.isFinite(NaN); // false Number.isFinite(Infinity); // false Number.isFinite(-Infinity); // false Number.isFinite('foo'); // false Number.isFinite('15'); // false Number.isFinite(true); // false Number.isNaN()检查一个数字是否是NaN 如果参数类型不是NaN，Number.isNaN一律返回falseNumber.isNaN(NaN) // true Number.isNaN(\"NaN\") // false Number.isNaN(1) // false Number.parseInt()强制转换为Int Number.parseFloat()强制转换为Float Number.isSafeInteger()判断一个整数是否在javascript的精确范围之内JavaScript 能够准确表示的整数范围在-2^53^ 到2^53^之间（不含两个端点 新增常量 Number.EPSILON javascript所能表示的最小精度 Number.MAX_SAFE_INTEGER精度最大值 Number.MIN_SAFE_INTEGER精度最小值 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Markdown使用方法/":{"url":"Markdown使用方法/","title":"Markdown使用方法","keywords":"","body":" 说明 Markdown 的使用方法 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Markdown使用方法/Markdown绘图指南/":{"url":"Markdown使用方法/Markdown绘图指南/","title":"Markdown绘图指南","keywords":"","body":"Markdown绘图指南 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Markdown使用方法/Markdown绘图指南/Mermaid使用说明.html":{"url":"Markdown使用方法/Markdown绘图指南/Mermaid使用说明.html","title":"Mermaid使用说明","keywords":"","body":" mermaid plantUML使用说明 一.参考地址 二.常用模型 1.Flowchar(流程图) 2.时序图 3.饼图 4.甘特图 5.类图(PlantUMl) mermaid plantUML使用说明 一.参考地址 参考地址 二.常用模型 1.Flowchar(流程图) graph TD A[Hard] -->|Text| B(Round) B --> C{Decision} C -->|One| D[Result 1] C -->|Two| E[Result 2] graph TD A[Hard] -->|Text| B(Round) B --> C{Decision} C -->|One| D[Result 1] C -->|Two| E[Result 2] 2.时序图 ATM取款 sequenceDiagram participant A as 客户 participant B as 取款机 participant C as 银行 Alt 取款金额 > 10000 A ->> +B : 请求取款 B ->> -A : 取款金额每次不得超过10000 else 取款金额 > +B : 请求取款 B ->> +C : 取款请求 C ->> -B : 返回结果 B ->> -A : 返回结果 end opt 取款 A ->> +B : 请求取款 B ->> +C : 取款请求 C ->> -B : 返回结果 B ->> -A : 返回结果 end loop everyMinute A ->> B : 查询存款 B ->> A : 返回结果 end sequenceDiagram participant A as 客户 participant B as 取款机 participant C as 银行 Alt 取款金额 > 10000 A ->> +B : 请求取款 B ->> -A : 取款金额每次不得超过10000 else 取款金额 > +B : 请求取款 B ->> +C : 取款请求 C ->> -B : 返回结果 B ->> -A : 返回结果 end opt 取款 A ->> +B : 请求取款 B ->> +C : 取款请求 C ->> -B : 返回结果 B ->> -A : 返回结果 end loop every Minute A ->> +B : 查询存款 B ->> -A : 返回结果 end 3.饼图 pie title 动物数 \"Dogs\" : 386 \"Cats\" : 85 \"Rats\" : 150 \"Cows\" : 150 pie title 动物数 \"Dogs\" : 386 \"Cats\" : 85 \"Rats\" : 150 \"Cows\" : 150 4.甘特图 gantt title ganttDiagram dateFormat YYYY-MM-DD section Section A task :done,a1,2020-05-10,30d Another task :active,after a1,20d section Section2 B task :crit,a1,2020-05-10,20d C task :crit,a2,2020-05-10,2020-05-20 gantt title ganttDiagram dateFormat YYYY-MM-DD section Section A task :done,a1,2020-05-10,30d Another task :active,after a1,20d section Section2 B task :crit,a1,2020-05-10,20d C task :crit,a2,2020-05-10,2020-05-20 5.类图(PlantUMl) var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"命令学习/":{"url":"命令学习/","title":"命令学习","keywords":"","body":" 常用命令行命令 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"命令学习/1.xcode命令.html":{"url":"命令学习/1.xcode命令.html","title":"1.xcode命令","keywords":"","body":" Xcode命令 一.Command Line Tool安装 通过终端安装 xcode-select --install 安装成功后再次输入 xcode-select --install 出现以下提示说明安装成功 二.xcode--select常用命令 显示帮助 xcode-select --help 打印安装位置 xcode-select --print-path 显示版本号 xcode-select --version 命令重置 xcode-select --reset 设置默认版本 sudo xcode-select -switch Xcode.app 3.xcodebuild的一些常用命令 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"GLOSSARY.html":{"url":"GLOSSARY.html","keywords":"","body":" Git 分散式版本控制软件 Markdown Aaron Swartz 跟John Gruber共同设计的排版语言 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"}}