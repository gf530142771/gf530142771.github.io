<!-- TOC -->

- [泛型](#泛型)
    - [写法](#写法)
    - [基本使用](#基本使用)
    - [泛型类](#泛型类)
    - [泛型约束](#泛型约束)

<!-- /TOC -->
## 泛型 

### 写法
```ts
function Identify<T>(args:T):T{
    return args;
}

//完整写法
console.log(Identify<string>('helllo'));

//ts会进行推断 可以简写
console.log(Identify(10));
console.log(Identify('hello world'));
console.log(Identify({a:100}));
```

### 基本使用
与普通类型差别不大 可以这样使用
* 泛型变量
```ts
let generic1:<U>(args:U)=>U = Identify;
```
* 使用带有签名的对象字面量
```ts
let generic2:{<U>(args:U):U} = Identify
```
* 泛型接口
```ts
interface IGeneric{
    <T>(args:T):T
}
let generic3:IGeneric = Identify
```

### 泛型类
```ts
class GenericNumber<T> {
    zeroValue: T;
    add: (x: T, y: T) => T;
}

let myGenericNumber = new GenericNumber<number>();
myGenericNumber.zeroValue = 0;
myGenericNumber.add = function(x, y) { return x + y; };
```

### 泛型约束
* 使用接口约束  

```ts
class GenericNumber<T> {
    zeroValue: T;
    add: (x: T, y: T) => T;
}

let myGenericNumber = new GenericNumber<number>();
myGenericNumber.zeroValue = 0;
myGenericNumber.add = function(x, y) { return x + y; };
```

* 使用类型约束  

```ts
function getProperty<T,K extends keyof T>(obj: T, key: K) {
    return obj[key];
}

let x = { a: 1, b: 2, c: 3, d: 4 };

getProperty(x, "a"); // okay
```

* 使用类类型  

```ts
function create<T>(c: {new(): T; }): T {
    return new c();
}
```
