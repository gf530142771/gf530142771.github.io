## 长连接

### WebSocket 
CocosCreator推荐使用。  

#### 简单使用
```js
let ws = new WebSocket("ws://echo.websocket.org");
 ws.onopen = function (event) {
     console.log("Send Text WS was opened.");
 };
 ws.onmessage = function (event) {
     console.log("response text msg: " + event.data);
 };
 ws.onerror = function (event) {
     console.log("Send Text fired an error");
 };
 ws.onclose = function (event) {
     console.log("WebSocket instance closed.");
 };

 setTimeout(function () {
     if (ws.readyState === WebSocket.OPEN) {
         ws.send("Hello WebSocket, I'm a text message.");
     }
     else {
         console.log("WebSocket instance wasn't ready...");
     }
 }, 3);
```

#### 自己封装的工具类(未完成版本,后续优化)
```js
let instance = Symbol("instance");
let socket = Symbol("socket");
export class WebSocketUtils {
    constructor() {

    }
    static getInstance() {
        if (this[instance] == null) {
            this[instance] = new WebSocketUtils();
        }
        return this[instance];
    }

    connect(url) {
        if (this[socket] == null) {
            this[socket] = new WebSocket(url);
            this[socket].binaryType = "arraybuffer";
            this[socket].onopen = this.onOpen.bind(this);
            this[socket].onmessage = this.onMessage.bind(this);
            this[socket].onclose = this.onClose.bind(this);
            this[socket].onerror = this.onError.bind(this);

            // this[socket].addEventListener('open', function (event) {
            //     console.log(WebSocketUtils.name + " onOpe2");
            // });
            // this[socket].addEventListener('open', function (event) {
            //     console.log(WebSocketUtils.name + " onOpen3");
            // });
        } else {
            this.close();
        }
    }

    onOpen() {
        console.log(WebSocketUtils.name + " onOpen");
    }

    onMessage(message) {
        console.log(WebSocketUtils.name + " onMessage", message);
    }

    onClose() {
        console.log(WebSocketUtils.name + " onClose");
        this.close();
    }

    onError(message) {
        console.log(WebSocketUtils.name + " OnError", message);
        this.close();
    }

    close() {
        if (this[socket]) {
            this[socket].close();
            this[socket] = null;
        }
    }
    sendData(message) {
        try {
            this[socket].send(message);
        } catch (error) {
            console.log(WebSocketUtils.name + "sendData" + error);
        }
    }
}
```

### SocketIO  
cocoscreator 不支持此方法，用户需要根据平台自己添加

目前本人只完成了js版本，其他平台版本后续更新
```js
import { Facade } from "../Facade";

export const SOCKET_ERROR = {
    SOCKET_ERROR_DISCONNET: "SOCKET_ERROR_DISCONNET",//连接断开
    SOCKET_ERROR_SOCKET_NOT_NULL: "SOCKET_ERROR_SOCKET_NOT_NULL",//
};
Object.freeze(SOCKET_ERROR);

export const SOCKET_EVENT = {
    SOCKET_EVENT_CONNECT: "SOCKET_EVENT_CONNECT",//连接成功
    SOCKET_EVENT_DISCONNECT: "SOCKET_EVENT_DISCONNECT",//连接断开
    SOCKET_EVENT_CONNECT_ERROR: "SOCKET_EVENT_CONNECT_ERROR",//连接出现错误
}
Object.freeze(SOCKET_EVENT);



let symbolSocket = Symbol("socket");
let instance = Symbol("instance");
export class SocketIOUtils {
    constructor() {
        //socket实例
        this[symbolSocket] = null;
    }

    static getInstance() {
        if (!this[instance]) {
            this[instance] = new SocketIOUtils();
        }
        return this[instance];
    }
    /**
     * 
     * @param {String} url 服务器地址  
     */
    connect(url) {
        if (this[symbolSocket] == null) {
            this[symbolSocket] = window.io(url, {
                transports: ['websocket'],
                'force new connection': true,
            });
            this[symbolSocket].on("connect", (data) => {
                console.log("SocketIOUtils  connect : " + data);
                Facade.getInstance().sendNotify(SOCKET_EVENT.SOCKET_EVENT_CONNECT, data)
                //发送连接成功的事件
            });
            this[symbolSocket].on("disconnect", (data) => {
                //发送连接失败的事件
                console.log("SocketIOUtils disconnect : " + data);
                Facade.getInstance().sendNotify(SOCKET_EVENT.SOCKET_EVENT_DISCONNECT, data);
                this.disConnect();
            });
            this[symbolSocket].on("connect_error", (data) => {
                //发送连接错误的事件
                console.log("SocketIOUtils  connectError : " + data);
                Facade.getInstance().sendNotify(SOCKET_EVENT.SOCKET_EVENT_CONNECT_ERROR, data);
                this.disConnect();
            });

            this[symbolSocket].on("chat message", function (message) {
                //服务器发来消息
                console.log("chat message : " + message);
            });
        }
        else {
            console.log("disconnect");
            this.disConnect();
        }
    }

    sendData(data, callback) {
        try {
            this[symbolSocket].emit("sendMessage", data, typeof callback === "function" ? callback : (message) => {
                console.log("sendData success" + message);
            });
        }
        catch (err) {
            console.log("send data error ", err);
        }
        // if (this[symbolSocket]) {

        // }else{
        //     throw error()
        // }
    }
    /**
     * 断开连接
     */
    disConnect() {
        if (this[symbolSocket]) {
            this[symbolSocket].close();
            this[symbolSocket] = null;
        }
    }
}
```
[socket.io.js](./socket.io.js)
